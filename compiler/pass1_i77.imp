{ IMP77 compiler  first pass }

{ ############################################################ }
{ # This program is a Copyright work.                        # }
{ #                                                          # }
{ # Over the last 40+ years a long and distinguished list of # }
{ # institutions, individuals and other entities have made   # }
{ # contributions to portions of this program and may have a # }
{ # reasonable claim over rights to certain parts of the     # }
{ # program.                                                 # }
{ #                                                          # }
{ # This version is therefore provided for education and     # }
{ # demonstration purposes only                              # }
{ ############################################################ }

{ JDM tweaks                                                   }
{ 1) Source layout altered to more clearly show code for the   }
{    actions, pactions etc                                     }
{    Declaration order in a routine usually given as:-         }
{    1.1) Format definitions                                   }
{    1.2) Constants                                            }
{    1.3) Own variables                                        }
{    1.4) Variables                                            }
{    1.5) Routines                                             }
{    1.6) Code for routine                                     }
{ 2) Most ! comments replaced by the curly bracket comment     }
{    layout. This avoids confusion with the use of ! for a     }
{    bitwise or operation                                      }
{ 3) The statement terminator ; eliminated as much as possible }
{    This has caused extra lines of code to be added which the }
{    original source would have used overlapping code and      }
{    extra "goto" or "->" IMP statements.                      }
{ 4) In addition the IMP grammar has been altered to eliminate }
{    the ADDOP phrase, to make the syntax closer to that used  }
{    by PSR                                                    }
{ 5) string() map used to obtain identifier + include file     }
{                                                              }
{ N.B. IMP77 uses the %switch statement as a computed goto     }
{      This is akin to the C switch statement.                 }
{      A PASCAL style case statement would be syntactically    }
{      nicer for source layout                                 }
{                                                              }
{ N.B. This IMP77 compiler ass-u-mes that the target machine   }
{      is:                                                     }
{      1) byte addressable                                     }
{      2) has 32-bit and 8-bit arithmetic instructions         }
{      3) base address byte holds the least significant byte   }

%externalstring(15) P1 Version = "8.4-2024.12.18"

! This source file is using the IMP: mechanism to determine the folder
! containing the requested include file
%include "IMP:Stream3L.inc"
%include "IMP:Option3L.inc"

%externalstring(255)%fn %spec Actual Include %alias "ACTINC"(%string(255) F, M)
%constbytearray Include Stream(0:4) = Source, 3,4,5,6

%externalroutine pass1( %integername No stats, No Faults, No Warnings,
                        %integer Options )

! Wee change needed to cross-compile the compiler when 
! going from 16 bit to 32 bit world
!    %constinteger minus one    = 16_7fff;
    { configuration parameters                              }
    { minus one represents all bits set for an %integer     }
    { %integer could be 16,32,64 bits wide depending on the }
    { processor being targeted                              }
    { i.e 8086 (16 bits), 80386 (32 bits), i86_64 (64 bits) }

    { now to set up various constants }
    %constinteger max int      = ((-1)>>1)//10
    %constinteger max dig      = (-1)>>1-maxint*10
    %constinteger byte size    = 8         { bits per byte }
    %constinteger max tag      = 3200      { max no. of tags }
    %constinteger max dict     = 10000     { max extent of dictionary }
    %constinteger name bits    = 11        { name table size as a power of 2 }
    %constinteger max names    = 1<<namebits-1 { table limit as mask, eg 255 }
    %constinteger lit max      = 60        { max no. of constants/stat. }
    %constinteger rec size     = 1000      { size of analysis record }
    %constinteger dim limit    = 6         { maximum array dimension }

    { symbols }
    %constinteger ff     = 12              { form feed }
    %constinteger marker = '^'             { marker for faults }
    %constinteger squote = '"'             { string quote }
    %constinteger cquote = ''''            { character quote }

    { types }
    %constinteger integer = 1
    %constinteger real    = 2
    %constinteger stringv = 3
    %constinteger record  = 4

    { forms }
    %constinteger iform   = integer<<4+1
    %constinteger lab     = 3
    %constinteger recfm   = 4
    %constinteger proc    = 7   { PROC"       class for proc    }
    %constinteger termin  = 20  { T"          ;                 }
    %constinteger comment = 22  { COMMENT"    COMMENT           }
    %constinteger jump    = 54  { JUMP"       ->                }
    %constinteger var     = 91  { V           [simple variable] }
    %constinteger const   = 93  { CONST       [constant]        }
    %constinteger swit    = 105 { S           [switch]          }

    { phrase entries }
    %constinteger escdec   = 252
    %constinteger escproc  = 253
    %constinteger escarray = 254
    %constinteger escrec   = 255

    %recordformat arfm(%shortinteger class,sub,link,ptype,papp,pformat,x,pos)

    %recordformat tagfm(%integer app, format,
                        %shortinteger flags, index, text, link)

    { flags }
    {      *===.===.===.===.===.====.====.====.===.======.======* }
    {      ! u ! c ! c ! p ! s ! a  ! o  ! pr ! s ! type ! form ! }
    {      ! 1 ! 1 ! 1 ! 1 ! 1 ! 1  ! 1  ! 1  ! 1 !  3   !  4   ! }
    {      *===^===^===^===^===^====^====^====^===^======^======* }
    {        u   c   c   p   s   a    o    p    s    t      f     }
    {        s   l   o   a   u   n    w    r    p    y      o     }
    {        e   o   n   r   b   a    n    o    e    p      r     }
    {        d   s   s   a   n   m         t    c    e      m     }
    {            e   t   m   a   e                                }
    {            d       s   m                                    }
    {                        e                                    }
    {                                                             }

    %constinteger used bit   = b'1000000000000000'
    %constinteger closed     = b'0100000000000000'
    %constinteger const bit  = b'0010000000000000'
    %constinteger parameters = b'0001000000000000'
    %constinteger subname    = b'0000100000000000'
    %constinteger aname      = b'0000010000000000'
    %constinteger own bit    = b'0000001000000000'
    %constinteger prot       = b'0000000100000000'
    %constinteger spec       = b'0000000010000000'

    %constinteger trans bit  = x'4000'
    %constinteger error      = x'8000'

    %record(arfm)%array ar(1:rec size)

    %owninteger spare names  = max names
    %owninteger class        = 0          { class of atom wanted }
    %owninteger x            = 0          { usually last tag }
    %owninteger atom1        = 0          { atom class (major) }
    %owninteger atom2        = 0          { atom class (minor) }
    %owninteger subatom      = 0          { extra info about atom }
    %owninteger type         = 0
    %owninteger app          = 0
    %owninteger format       = 0          { atom info }
    %owninteger faulty       = 0          { fault indicator }
    %owninteger fault rate   = 0          { fault rate count }
    %owninteger lines        = 0          { current line number }
    %owninteger text line    = 0          { starting line for string const }
    %owninteger margin       = 0          { statement start margin }
    %owninteger error margin = 0
    %owninteger error sym    = 0
    %owninteger column       = 0
    %owninteger stats        = 0          { statements compiled }
    %owninteger mon pos      = 0          { flag for diagnose }
    %owninteger sym          = nl         { current input symbol }
    %owninteger symtype      = 0          { type of current symbol }
    %owninteger quote        = 0          { >0 strings, <0 chars }
    %owninteger end mark     = 0          { %end flag }
    %owninteger cont         = ' '
    %owninteger csym         = ' '        { listing continuation marker }
    %owninteger decl         = 0          { current declarator flags }
    %owninteger dim          = 0          { arrayname dimension }
    %owninteger spec given   = 0

    %owninteger escape class = 0          { when and where to escape }
    %owninteger protection   = 0
    %owninteger atom flags   = 0
    %owninteger otype        = 0          { current 'own' type }
    %owninteger reals ln     = 1          { =4 for %REALSLONG }
    %owninteger last1        = 0          { previous atom class }
    %owninteger gen type     = 0
    %owninteger ptype        = 0          { current phrase type }
    %owninteger papp         = 0          { current phrase parameters }
    %owninteger pformat      = 0          { current phrase format }
    %owninteger force        = 0          { force next ptype }
    %owninteger g            = 0
    %owninteger gg           = 0
    %owninteger map gg       = 0          { grammar entries }
    %owninteger fdef         = 0          { current format definition }
    %owninteger this         = -1         { current recordformat tag }
    %owninteger nmin         = 0          { analysis record atom pointer }
    %owninteger nmax         = 0          { analysis record phrase pointer }
    %owninteger rbase        = 0          { record format definition base }
    %owninteger dmax         = 1
    %owninteger tmin         = max tag    { upper bound on tags }
    %owninteger ss           = 0          { source statement entry }
    %string(255) include file = ""
    %owninteger include level= 0
    %owninteger include list = 0
    %owninteger include      = 0          { =0 unused, #0 being used }
    %owninteger perm         = 1          { 1 = compiling perm, 0 = program }
    %owninteger progmode     = 0          { -1 = file, 1 = begin/eop }
    %owninteger sstype       = 0          { -1:exec stat }
                                          {  0: declaration }
                                          {  1: block in }
                                          {  2: block out }
    %owninteger spec mode    = 0          { >=0: definition }
                                          {  -1: proc spec }
                                          {  -2: recordformat }
    %owninteger ocount       = -1         { own constants wanted }
    %owninteger limit        = 0          { lookup limit }
    %owninteger copy         = 0          { duplicate name flag }
    %owninteger order        = 0          { out of sequence flag }
    %owninteger for warn     = 0          { non-local flag }
    %owninteger dubious      = 0          { flag for dubious statements }
    %owninteger dp           = 1
    %owninteger pos1         = 0
    %owninteger pos2         = 0          { error position }
    %owninteger pos          = 0          { input line index }
    %owninteger dimension    = 0          { current array dimension }
    %owninteger local        = 0          { search limit for locals }
    %owninteger fm base      = 0          { entry for format decls }
    %owninteger search base  = 0          { entry for record_names }
    %owninteger format list  = 0          { size of current format list }
    %integer recid
    %ownbyteintegerarray char(0:133) = nl(134)  { input line }
    %integerarray lit pool(0:lit max)
    %owninteger lit          = 0          { current literal (integer) }
    %owninteger lp           = 0          { literals pointer }
    %owninteger block x      = 0          { block tag }
    %owninteger list         = 1          { <= to enable }
    %owninteger quiet        = 0          { #0 to inhibit all listing }
    %owninteger tty          = 0          { non-zero if listing to tty }
    %owninteger control      = 0
    %owninteger diag         = 0          { diagnose flags }
    %integer hash value
    %shortintegerarray hash(0:max names)
    %record(tagfm)%array tag(0:max tag)
    %integerarray dict(1:max dict)

    %recordformat subtagfm(%string(255) name, %shortinteger format, flags, index )

    %constinteger aref max = 16
    %integer      aref count = 0
    %ownrecord(subtagfm)%array aref(1:aref max)
    %record(subtagfm)%name s

    { grammar related constants }
    %constinteger max grammar  = 1720
    %owninteger gmin         = max grammar     { upper bound on grammar }
    %constinteger manifest   = 120
    %constinteger figurative = 130
    %constinteger actions    = 180
    %constinteger phrasal    = 200

    { various icode utility functions }
    %include "icd.utils.inc"

    { definitions of iCode values used by pass1 and pass2 }
    %include "icd.types.inc"
    { definition of icode buffer routines }
    %include "buffer.inc"

    { *** start of generated tables *** }
    %include "i77.tables.inc"
    { ***  end  of generated tables *** }

    %constbyteintegerarray amap(0:15) = %c
         89  { ADDOP                       },
         91  { V     [simple variable]     },
         92  { N     [pointer variable]    },
         104 { L     [label]               },
         94  { FM    [recordformat]        },
         93  { CONST [constant]            },
         105 { S     [switch]              },
         100 { RP    [routine parameter]   },
         101 { FP    [function parameter]  },
         102 { MP    [map parameter]       },
         103 { PP    [predicate parameter] },
         106 { A     [array]               },
         107 { AN    [arrayname]           },
         108 { NA    [name array]          },
         109 { NAN   [namearrayname]       },
         89  { ADDOP                       }

    %constbyteintegerarray atoms(0:15) = 89 { ADDOP   },
                                          1 { VDEC    },
                                          1 { VDEC    },
                                         10 { SWDEC   },
                                          9 { FORMDEC },
                                          1 { VDEC    },
                                         10 { SWDEC   },
                                          7 { PROC    },
                                          7 { PROC    },
                                          7 { PROC    },
                                          7 { PROC    },
                                          4 { ADEC    },
                                          1 { VDEC    },
                                          4 { ADEC    },
                                          1 { VDEC    },
                                         89 { ADDOP   }

    { obtain a dict string using the string() map }
    %string(255) %function form dict string(%integer m)
        %string(255) s

        s = string(addr(dict(m)))
        %result = s
    %end { of "form dict string" }

    %string(255) %function get ident(%integer p)
        %integer m
        %string(255) s

        %if (tag(p)_text = 0) %start
            s = "?"
        %finish %else %start
            m = tag(p)_text + 1        { advance to name string }
            s = form dict string(m)
        %finish

        %result = s
    %end { of "get ident" }

    %predicate dict match( %integer name1, name2 )
        %true %if form dict string( name1 ) = form dict string( name2 )
        %false
    %end { of "dict match" }

    %routine abandon(%integer n)
        %switch reason(0:15)
        %integer stream

        stream = listing
        %cycle
            newline %if (sym # nl)
            printsymbol('*')
            write(lines,4)
            space
            ->reason(n)

reason(0):  printstring("compiler error!")
            ->more

reason(1):  printstring("switch vector too large")
            ->more

reason(2):  printstring("too many names")
            ->more

reason(3):  printstring("program too complex")
            ->more

reason(4):  printstring("feature not implemented")
            ->more

reason(5):  printstring("input ended: ")
            %if (quote # 0) %start
                %if (quote < 0) %then printsymbol(cquote) %else printsymbol(squote)
            %finish %else %start
                printstring("%endof")
                %if (progmode >= 0) %then printstring("program") %else printstring("file")
            %finish
            printstring(" missing?")
            ->more

reason(6):  printstring("too many faults!")
            ->more

reason(7):  printstring("string constant too long")
            ->more

reason(8):  printstring("dictionary full")
            ->more

reason(9):  printstring("Included file ".include file." does not exist")
            ->more

reason(10): printstring("Include files nested too deeply")
            ->more

reason(11): printstring("Array reference stack overflow.")
            printstring(" Increase 'aref max' ("); write(aref max,0); printstring(")")
            ->more

reason(12): printstring("Array reference stack underflow.")
            printstring(" Array reference count='"); write(aref count, 0); printstring("'")
            ->more

reason(*):  printstring("Unknown reason triggering pass1 'abandon'")
            ->more

more:       newline
            printstring("***  compilation abandoned ***")
            newline
            %exit %if (stream = report) %or (tty # 0)
            close output
            stream = report
            select output(report)
        %repeat

        { %signal 14,15 %if (diag&4096 # 0) }
        %stop
    %end { of "abandon" }

    %routine set const(%integer m)
        { load the PUSHI icode instruction }
        add char(iCodePUSHI)
        { now store the 32-bit integer as 4 bytes as described }
        add long( m )
    %end { of "set const" }

    %routine compile block(%integer level, block tag, dmin, tmax, id)
        %integerfnspec gapp
        %routinespec delete names(%integer quiet)
        %routinespec analyse
        %routinespec compile

        %integer open;    open    = closed { zero if can return from proc }
        %integer dbase;   dbase   = dmax   { dictionary base }
        %integer tbase;   tbase   = tmax   { tag base }
        %integer tstart;  tstart  = tmax
        %integer label;   label   = 4      { first internal label }
        %integer access;  access  = 1      { non-zero if accessible }
        %integer inhibit; inhibit = 0      { non-zero inhibits declaratons }

        %integername block app; block app   == tag(block tag)_app
        %integer block fm;      block fm     = tag(block tag)_format
        %shortintegername bflags;    bflags      == tag(block tag)_flags
        %integer block type;    block type   = bflags>>4&7
        %integer block form;    block form   = bflags&15
        %integer block otype;   block otype  = otype

        %integer labxx, new app

        { -5 : -1  - warnings }
        {  1 : 23  - errors }
        %routine fault(%integer n)
            %switch fm(-5:22)
            %integer st

            %routine print ss
                %integer s, p

                %return %if (pos = 0)
                space
                p = 1
                %cycle
                    printsymbol(marker) %if (p = pos1)
                    %exit %if (p = pos)
                    s = char(p)
                    p = p+1
                    %exit %if (s = nl) %or ((s='%') %and (p = pos))
                    %if (s < ' ') %start   { beware of tabs }
                        %if (s = ff) %then s = nl %else s = ' '
                    %finish
                    printsymbol(s)
                %repeat
                pos = 0 %if (list <= 0)
            %end { of "print ss" }

            pos1 = pos2 %if (pos2 > pos1)
            newline %if (sym # nl)
            st = report
            %if (n = -3) %or (tty # 0) %start   { unused or listing to console }
                st = listing
                Pos = 0    { inhibit PRINT SS }
            %finish

            %cycle
                select output(st)
                %if (n < 0) %then printsymbol('?') %and pos1 = 0 %else printsymbol('*')
                %if (st # report) %start
                    %if (list <= 0) %and (pos1 # 0) %start
                        spaces(pos1+margin)
                        printstring("      ! ")
                    %finish
                %finish %else %start
                    printstring(include file) %if (include # 0)
                    write(lines, 4)
                    printsymbol(csym)
                    space
                %finish

                No Warnings = No Warnings + 1 %if (n < 0)
                No Faults   = No Faults + 1   %if (n > 0)

                ->fm(n) %if (-5 <= n <= 22)

                printstring("Unspecified fault")
                write(n, 2)
                print ss
                ->esac

fm(-5):         dubious = 0
                pos1 = 0
                printstring("Dubious statement")
                print ss
                ->esac

fm(-4):         pos1 = for warn
                for warn = 0
                printstring("Non-local")
                print ss
                ->esac

fm(-3):         printstring(get ident(x)." unused")
                ->esac

fm(-2):         printsymbol('"')
                printsymbol('}')
                printsymbol('"')
                printstring(" missing")
                ->esac

fm(-1):         pos1 = 0
                printstring("access")
                print ss
                ->esac

fm(0):          printstring("form")
                print ss
                newline
                ->esac

fm(1):          printstring("atom")
                print ss
                ->esac

fm(2):          printstring("not declared")
                print ss
                ->esac

fm(3):          printstring("too complex")
                print ss
                ->esac

fm(4):          printstring("duplicate ".get ident(x))
                print ss
                ->esac

fm(5):          printstring("type")
                print ss
                ->esac

fm(6):          pos1 = 0
                printstring("match")
                print ss
                ->esac

fm(7):          pos1 = 0
                printstring("context")
                print ss
                ->esac

fm(8):          printstring("%cycle missing")
                ->esac

fm(9):          printstring("%start missing")
                ->esac

fm(10):         printstring("size")
                write(lit, 1) %if pos1 = 0
                print ss
                ->esac

fm(11):         printstring("bounds")
                write(ocount, 1) %unless ocount < 0
                print ss
                ->esac

fm(12):         printstring("index")
                print ss
                ->esac

fm(13):         pos1 = 0
                printstring("order")
                print ss
                ->esac

fm(14):         printstring("not a location")
                print ss
                ->esac

fm(15):         printstring("%begin missing")
                ->esac

fm(16):         printstring("%end missing")
                ->esac

fm(17):         printstring("%repeat missing")
                ->esac

fm(18):         printstring("%finish missing")
                ->esac

fm(19):         printstring("result missing")
                ->esac

fm(20):         printsymbol('"')
                printstring("""".get ident(x).""" missing")
                ->esac

fm(21):         printstring("context ".get ident(this))
                print ss
                ->esac

fm(22):         printstring("format")
                print ss
                ->esac

esac:
                newline
                %exit %if (st = listing)
                st = listing
            %repeat

            %if (n >= 0) %start
                { %signal 14,15 %if (diag&4096 # 0) }
                %if (n # 13) %start        { order is fairly safe }
                    ocount = -1
                    gg = 0
                    copy = 0
                    quote = 0
                    search base = 0
                    escape class = 0
                    gg = 0
                %finish
                faulty = faulty+1
   
                { check that there haven't been too many faults }
                fault rate = fault rate+3
                abandon(6) %if (fault rate > 30)
                fault rate = 3 %if (fault rate <= 0)
            %finish
            tbase = tstart
            %if (list <= 0) %and (sym # nl) %start
                error margin = column
                error sym = sym
                sym = nl
            %finish
        %end { of "fault" }

        { generate app grammar (backwards) }
        %integerfn gapp
            %constinteger comma = 140           { 140 == PSEP }
            %routinespec set cell(%integer g, tt)
            %routinespec class(%record(tagfm)%name v)
            %record(tagfm)%name v
            %integer p, link, tp, c, ap, t

            { add the cell to the grammar, combining common tails }
            %routine set cell(%integer g, tt)

                %while (p # gmax) %cycle
                    p = p+1
                    %if (glink(p) = link) %and (gram(p) = g) %start
                        %if (tt < 0) %or ((gram(p+1) = tt) %and (glink(p+1)=ap)) %start
                            link = p            { already there }
                            %return
                        %finish
                    %finish
                %repeat

                { add a new cell }
                gmax = gmax+1
                gram(gmax) = g
                glink(gmax) = link
                link = gmax

                %if (tt >= 0) %start              { set type cell }
                    gmax = gmax+1
                    gram(gmax) = tt
                    glink(gmax) = ap
                %finish
                p = gmax

            %end { of "set cell" }

            %routine class(%record(tagfm)%name v)
                %constinteger err    = 89
                %constinteger rtp    = 100
                %constinteger fnp    = 101
                %constinteger mapp   = 102
                %constinteger predp  = 103
                %constintegerarray class map(0:15) = %c
                             err,   1764,    247,     err,
                             err,    err,    err,    -rtp,
                            -fnp,  -mapp, -predp,     err,
                             214,    err,    229,     err
                %integer tags, type, form

                ap = 0
                tags = v_flags
                type = tags>>4&7
                form = tags&15
                tp = v_format<<3!type
                c = class map(form)
                c = 208 %and tp = 0 %if (type = 0) %and (form = 2)  { %name }
                ap = v_app %if (tags&parameters # 0)
            %end { of "class" }

            %result = 0 %if (tmax = local)        { no app needed }

            p = gmax1
            link = 0
            t = tmax

            %cycle
                v == tag(t)
                t = t-1
                class(v)                        { deduce class from tag }
                %if (c < 0) %start              { insert %PARAM==196 }
                    c = -c
                    set cell(196, tp)
                    tp = -1
                %finish
                set cell(c, tp)
                %exit %if (t = local)           { end of parameters }
                set cell(comma, -1)             { add the separating comma }
            %repeat
            abandon(3) %if (gmax > gmin)

            %result = link
        %end { of "gapp" }

        %routine delete names(%integer quiet)
            %integer flags
            %record(tagfm)%name tx

            %while (tmax > tbase) %cycle
                x = tmax
                tmax = tmax-1
                tx == tag(x)
                flags = tx_flags
                fault(20) %if (flags&spec # 0) %and (flags&own bit = 0)
                { spec with no definition & not external }
                %if (flags&used bit = 0) %and (level >= 0) %and (list <= 0) %start
                    fault(-3) %if (quiet = 0)                     { unused }
                %finish
                dict(tx_text&x'ffff') = tx_link
            %repeat
        %end { of "delete names" }

        %routine analyse
            %constinteger order bits = x'3000', order bit = x'1000'
            %constinteger escape     = x'1000'
            %integer strp, mark, flags, prot err, k, s, c
            %owninteger key = 0
            %shortinteger node
            %shortintegername z
            %record(arfm)%name arp
            %switch act(actions:phrasal), paction(0:15)

            { diagnostic trace routine (diagnose&1 # 0) }
            %routine trace analysis
                %integer a
                %owninteger la1=0, la2=0, lsa=0, lt=0

                %routine show(%integer a)
                    %if (0 < a < 130) %start
                        space
                        printstring(text(a))
                    %finish %else write(a, 3)
                %end { of "show" }

                newline %if (mon pos # pos) %and (sym # nl)
                mon pos = pos
                write(g, 3)
                space
                printstring(text(class))
                printsymbol('"') %if (gg&trans bit # 0)
                a = gg>>8&15
                %if (a # 0) %start
                    printsymbol('{')
                    write(a, 0)
                    printsymbol('}')
                %finish
                %if (atom1 # la1) %or
                    (atom2 # la2) %or 
                    (lsa # subatom) %or
                    (lt # type) %start
                    printstring(" [")
                    la1 = atom1
                    show(la1)
                    la2 = atom2
                    show(la2)
                    lsa = subatom
                    write(lsa, 3)
                    lt = type
                    write(lt, 5)
                    printsymbol(']')
                %finish
                newline
            %end { of "trace analysis" }

            %routine get sym
                readsymbol(sym)
                abandon(5) %if (sym < 0)
                pos = pos+1 %if (pos # 133)
                char(pos) = sym
                printsymbol(sym) %if (list <= 0)
                column = column+1
            %end { of "get sym" }

            %routine read sym
                %owninteger last = 0
                %constbyteintegerarray mapped(0:127) = %c
                  0,   0,   0,   0,   0,   0,   0,   0,
                  0,   0,  nl,   0,   3,   0,   0,   0,
                  0,   0,   0,   0,   0,   0,   0,   0,
                  0,   0,   0,   0,   0,   0,   0,   0,
                  0, '!', '"', '#', '$',   1, '&',  39,
                '(', ')', '*', '+', ',', '-', '.', '/',
                '0', '1', '2', '3', '4', '5', '6', '7',
                '8', '9', ':', ';', '<', '=', '>', '?',
                '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
                'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
                'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
                'X', 'Y', 'Z', '[', '\', ']', '^', '_',
                '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
                'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
                'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
                'X', 'Y', 'Z',   2, '|', '}', '~',   0

                {   0 = space                         }
                {   1 = %                             }
                {   2 = {                             }
                {   3 = ff                            }
                {   other values represent themselves }
                {   39 = ''''                         }

                %if (sym = nl) %start
s1:                 lines = lines+1
                    printsymbol(end mark) %if (end mark # 0)
s11:                pos = 0
                    pos1 = 0
                    pos2 = 0
                    margin = 0
                    column = 0
                    Last = 0
                    end mark = 0
                    %if (list <= 0) %start
                        %if (include # 0) %start
                            printstring(" &")
                            write(lines, -4)
                        %finish %else  write(lines, 5)
                        csym = cont
                        printsymbol(csym)
                        space
                        %if (error margin # 0) %start
                            lines = lines-1
                            spaces(error margin)
                            error margin = 0
                            %if (error sym # 0) %start
                                printsymbol(error sym)
                                pos = 1
                                char(1) = error sym
                                sym = error sym
                                error sym = 0
                                ->s5

                            %finish
                        %finish
                    %finish
s2:                 symtype = 1
                %finish

s3:             readsymbol(sym)
                abandon(5) %if (sym < 0)
                pos = pos+1 %if (pos # 133)
                char(pos) = sym
                printsymbol(sym) %if (list <= 0)
                column = column+1
s5:             %if (sym # nl) %start
                    last = sym
                    %return %if (quote # 0)                     { dont alter strings }
                    sym = mapped(sym&127)
                    %if (sym <= 3) %start                       { special symbol }
                        ->s2 %if (sym = 0)                      { space (or dubious control) }
                        symtype = 2 %and ->s3 %if (sym = 1)     { % }
                        cont = '+' %and ->s11 %if (sym = 3)     { ff }
                        { must be '{' }
                        %cycle
                            get sym
                            ->s3 %if (sym = '}')
                            ->s4 %if (sym = nl)
                        %repeat
                    %finish
                    key = kdict(sym)
                    %if (key&3 = 0) %and (symtype = 2) %start          { keyword }
                        %if (sym = 'C') %and (nextsymbol = nl) %start  { %c... }
                            getsym
                            cont = '+'
                            ->s1

                        %finish
                    %else
                        symtype = key&3-2
                    %finish
                    %return
                %finish
s4:             symtype = quote
                ->s1 %if (last = 0) %and (Quote = 0)
                Cont = '+'
            %end { of "read sym" }

            %integerfn format selected
                format list = tag(format)_app       { number of names }
                %if (format list < 0) %start        { forward ref }
                    atom1 = error+22
                    %result = 0
                %finish
                %if (sym = '_') %start
                    escape class = esc rec
                    search base = tag(format)_format
                %finish
                %result = 1
            %end { of "format selected" }

            %routine code atom(%integer target)
                %integer dbase, da
                %integer base, n, mul, pend quote
                %integer j,k,l, pt

                { ABD - temp variable to help pack bytes into words }
                %integer flipflop

                %routine lookup(%integer d)
                    %integer new name, vid, k1, form
                    %record(tagfm)%name t
                    %integer new

                    { first locate the text of the name }
                    new = dmax+1  { points to text of string in dictionary }
                    k1 = hash value & max names     { rather crude hash }

                    %cycle
                        newname = hash(k1)
                        %exit %if (newname = 0)               { not in }
                        ->in %if dict match(newname+1, new)
                        k1 = (k1+1)&max names
                    %repeat

                    { not found }
                    spare names = spare names-1
                    abandon(2) %if (spare names <= 0)
                    hash(k1) = dmax                           { put it in }
                    dict(dmax) = -1
                    newname = dmax
                    dmax = dp
                    ->notin

in:                 search base = rbase %if (this >= 0) %and (d # 0)  { record elem defn }
                    %if (search base # 0) %start                      { record subname }
                        new = -1
                        x = search base
                        %cycle
                            ->notin %if (x < format list)
                            %exit %if (tag(x)_text = new name)
                            x = x-1
                        %repeat
                    %finish %else %start           { hash in for normal names }
                        x = dict(newname)
                        ->notin %if (x <= limit)   { wrong level }
                    %finish

                    subatom = x                    { name found, extract info }
                    t == tag(x)
                    atom flags = t_flags
                    format = t_format
                    app = t_app
                    protection = atom flags&prot
                    type = atom flags>>4&7
                    atom1 = amap(atom flags&15)

                    %if (diag&8 # 0) %start
                        printstring("lookup:")
                        write(atom1, 3)
                        write(type, 1)
                        write(app, 3)
                        write(format, 5)
                        write(atom flags, 3)
                        newline
                    %finish

                    %if (d = 0) %start            { old name wanted }
                        t_flags = t_flags!used bit
                        search base = 0

                        %if (atom flags&subname # 0) %and (format # 0) %start   { a record }
                            %return %if (format selected = 0)
                        %finish

                        %if (atom flags&parameters # 0) %start  { proc or array }
                            %if (app = 0) %start                { no parameters needed }
                                atom2 = atom1
                                atom1 = atom1-4
                                { 97 == [function call]}
                                { 98 == [map call]}
                                %if (97 <= atom1 <= 98) %start
                                    map gg = atom1
                                    atom1 = var
                                %finish
                            %finish %else %if (sym = '(') %start
                                search base = 0             { ignore format for now }
                                %if (atom1 >= 106) %start   { arrays }
                                    app = phrase(app+200)
                                    escape class = esc array
                                    atom1 = (atom1-106)>>1+91   { a,an->v  na,nan->n }
                                %finish %else %start            { procedures }
                                    escape class = esc proc
                                    atom1 = atom1-4
                                %finish
                                {200 APP}
                                phrase(200) = app
                            %finish
                            pos2 = pos
                            %return
                        %finish

                        { deal with constintegers etc }
                        %if (atom flags&const bit # 0) %and (atom1 = var) %start
                            map gg = const
                            atom2 = const
                            subatom = -subatom %if (type = integer)
                        %finish
                        %return
                    %finish

                    { new name wanted }
                    ->notin %if (tbase # tstart)   { don't fault proc parm-parm }
                    %if (d = lab+spec+used bit) %start
                        t_flags = t_flags!used bit
                        %return
                    %finish
                    %if (atom flags&spec # 0) %start  { a spec has been given }
                        %if (d = lab) %start          { define label }
                            t_flags = t_flags-spec
                            %return
                        %finish
                        %if (7 <= decl&15 <= 10) %and (decl&spec = 0) %start
                            {procedure definition after spec}
                            %if ((decl!!atom flags)&b'1111111' = 0) %start    { correct type? }
                                t_flags = t_flags-spec
                                spec given = 1 { procedure }
                                %return
                            %finish
                            { note that an external procedure must be specced }
                            { as a non-external procedure. }
                        %finish

                        %if (decl&15 = recfm) %start  { recordformat }
                            t_flags = record<<4+recfm
                            t_format = fdef
                            %return
                        %finish
                    %finish
                    %return %if (last1 = jump) %and (atom1 = swit)
                    copy = x %if (copy = 0)
notin:              app = 0
                    vid = 0
                    atom1 = error+2

                    %return %if (d = 0)             { old name wanted }
                    type = d>>4&7
                    form = d&15
                    atom1 = amap(form)

                    %if (this < 0) %start           { normal scope }
                        new = newname
                        tmax = tmax+1
                        x = tmax
                    %finish %else %start            { recordformat scope }
                        new = -1
                        recid = recid-1
                        vid = recid
                        tmin = tmin-1
                        x = tmin
                        format list = tmin
                    %finish

                    %if (11 <= form <= 14) %start     { arrays }
                        dim = 1 %if (dim = 0)         { set dim for owns }
                        app = dim
                    %finish

                    d = d!used bit %if ((otype > 2) %and (d&spec = 0)) %or (perm # 0) %or (Level = Include Level)

                    { external definitions need not be used in the file }
                    { in which they are defined, }
                    { so inhibit a useless unused warning. }

                    t == tag(x)
                    %if (form = lab) %start
                        id = id+1
                        vid = id
                    %finish
                    t_index = vid
                    t_text  = new name
                    t_flags = d
                    t_app   = app
                    t_format = fdef
                    format = fdef
                    subatom = x

                    %if (new >= 0) %start                 { insert into hash table }
                        t_link = dict(new)
                        dict(new) = x
                        %if (gmin = max grammar) %start   { proc param params }
                            tmin = tmin-1
                            subatom = tmin
                            tag(tmin) = t
                        %finish
                    %finish
                    abandon(3) %if (tmax >= tmin)
                %end { of "lookup" }

                %routine get(%integer limit)
                    %integer s, shift

                    shift = 0
                    %if (base # 10) %start
                        %if (base = 16) %start
                            shift = 4
                        %finish %else %if (base = 8) %start
                            shift = 3
                        %finish %else %if (base = 2) %start
                            shift = 1
                        %finish
                    %finish
                    n = 0
                    %cycle
                        %if (symtype = -1) %start     { digit }
                            s = sym-'0'
                        %finish %else %if (symtype < 0) %start        { letter }
                            s = sym-'A'+10
                        %finish %else %start
                            %return
                        %finish
                        %return %if (s >= limit)
                        pt = pt+1
                        glink(pt) = sym
                        %if (base = 10) %start        { check overflow }
                            %if (n >= max int) %and ((s > max dig) %or (n > max int)) %start
                                { too big for an integer, }
                                { so call it a real }
                                base = 0
                                type = real
                                n = 0
                            %finish
                        %finish
                        %if (shift = 0) %start
                            n = n*base+s
                        %finish %else %start
                            n = n<<shift+s
                        %finish
                        read sym
                    %repeat
                %end { of "get" }

top:            pos1 = pos
                subatom = 0
                pend quote = 0
                atom flags = 0     { ***new*** }

                { app and format must be left for assigning to papp & pformat }
                ->name %if (symtype = -2)         { letter }
                ->number %if (symtype < 0)        { digit }
                %if (symtype = 0) %start
                    atom1 = termin
                    atom2 = 0
                    %return
                %finish
                %if (symtype # 2) %start          { catch keywords here }
                    ->text %if (quote # 0)        { completion of text }
                    ->strings %if (sym = squote)  { start of string }
                    ->symbols %if (sym = cquote)  { start of symbol }
                    ->number %if (sym = '.') %and ('0' <= nextsymbol <= '9')
                %finish

                { locate atom in fixed dict }
                k = key>>2
                read sym
                %cycle
                    j = kdict(k)
                    %exit %if (j&x'4000' # 0)
                    %if (j&127 # sym) %or (symtype < 0) %start
                        ->err %unless (j < 0)
                        k = k+1
                    %finish %else %start
                        l = j>>7&127
                        read sym
                        %if (j > 0) %start
                            %if (l # 0) %start
                                ->err %if (l # sym) %or (symtype < 0)
                                read sym
                            %finish
                            l = 1
                        %finish
                        k = k+l
                    %finish
                %repeat
                atom1 = j&127
                %if (atom1 = 0) %start          { 19 == COMMA }
                    atom1 = 19
                    subatom = 19
                    atom2 = 0
                    %if (sym = nl) %start
                        %return %if (ocount >= 0)

                        { special action needs to be taken with <comma nl> as }
                        { const array lists can be enormous }
                        read sym
                    %finish
                    %return
                %finish
                atom2 = j>>7&127
                subatom = kdict(k+1)&x'3fff'
                { !!!!cont = ' ' }
                %return

                { report an error. adjust the error marker (pos1) to point }
                { to the faulty character in an atom, but care needs to be taken }
                { to prevent misleading reports in cases like ...????? }

err:            atom1 = error+1
                atom2 = 0
                pos1 = pos %if (pos-pos1 > 2)
                %return

                { take care with strings and symbol constants. }
                { make sure the constant is valid here before sucking it in }
                { (and potentially losing many lines)                       }

symbols:        atom1 = var
                atom2 = const
                type = integer
                map gg = const
                protection = prot
                subatom = lp
                abandon(3) %if (lp >= lit max)
                quote = \pend quote
                %return

                { an integer constant is acceptable so get it in and }
                { get the next atom }
chars:          n = 0
                cont = cquote
                %cycle
                    read sym
                    %if (sym = cquote) %start
                        %exit %if (nextsymbol # cquote)
                        read sym
                    %finish
                    %if n&(\((-1)>>byte size)) # 0 %start   { overflow }
                        pos1 = pos
                        atom1 = error+10
                        %return
                    %finish
                    ->err %if (quote = 0)
                    n = n<<byte size+sym
                    quote = quote+1
                %repeat
                quote = 0
                cont = ' '
                readsym %if (sym # nl)
                lit pool(lp) = n
                lp = lp+1
                ->top

                { sniff the grammar before getting the string }
strings:        atom1 = var
                atom2 = const
                type = stringv
                subatom = strp!x'4000'
                map gg = const
                protection = prot
                quote = subatom
                text line = lines                       { in case of errors }
                %return

                { a string constant is ok here, so pull it in and get }
                { the next atom }

text:           ->chars %if (quote < 0)                 { character consts }
                l = strp                                { point to beginning }
                k = 0                                   { length so far }
                flipflop = 0                            { space for the length is up the spout }

                %cycle
                    cont = squote
                    quote = 1
                    %cycle
                        read sym
                        %if (sym = squote) %start           { terminator? }
                            %exit %if (nextsymbol # squote) { yes -> }
                            read sym                        { skip quote }
                        %finish
                        %if (flipflop >= 0) %start
                            glink(strp) = sym<<8 + flipflop
                            strp = strp+1
                            flipflop = -1
                        %else
                            flipflop = sym
                        %finish
                        k = k+1
                        lines = text line %and abandon(7) %if (k > 255)   { too many chars }
                    %repeat
                    %if (flipflop >=0) %start                 { tail-end charlie }
                        glink(strp) = flipflop
                        strp = strp+1
                    %finish
                    glink(l) = glink(l)!k                   { plug in length }

                    quote = 0
                    cont = ' '
                    read sym
                    code atom(target)
                    %return %unless (atom1 = 48) %and (sym = squote)    { fold "???"."+++" }
                %repeat

number:         base = 10
bxk:            atom1 = var
                atom2 = const
                type = integer
                subatom = lp
                map gg = const
                protection = prot
                abandon(3) %if (lp >= lit max)
                pt = strp
                mul = 0
                %cycle
                    get(base)
                    %exit %unless (sym = '_') %and (base # 0) %and (pend quote = 0)   { change of base }
                    pt = pt+1
                    glink(pt) = '_'
                    read sym
                    base = n
                %repeat

                %if (pend quote # 0) %start
                    ->err %if (sym # cquote)
                    readsym
                %finish
                %if (sym = '.') %start    { a real constant }
                    pt = pt+1
                    glink(pt) = '.'
                    read sym
                    type = real
                    n = base
                    base = 0
                    get(n)
                %finish

                %if (sym = '@') %start    { an exponent }
                    pt = pt+1
                    glink(pt) = '@'
                    k = pt
                    readsym
                    type = integer
                    base = 10
                    %if (sym = '-') %start
                        read sym
                        get(10)
                        n = -n
                    %finish %else %start
                        get(10)
                    %finish
                    pt = k+1
                    glink(pt) = lp
                    litpool(lp) = n
                    lp = lp+1
                    atom1 = error+10 %if (base = 0)
                    type = real     { exponents force the type }
                %finish

                %if (type = real) %start
                    glink(strp) = pt-strp   { store the length (difference) }
                    subatom = (strp)!x'2000'
                    strp = pt+1
                %finish %else %start
                    litpool(lp) = n
                    lp = lp+1
                %finish
                %return

name:           atom1 = 0 %and %return %if (27 <= target <= 41)
                hash value = 0

                {*****************************}
                {*machine dependent for speed*}
                {*****************************}

                dp = dmax+1
                da = addr(dict(dp))
                dbase = da
                { prepare the dict array to add an ident string }
                dict(dp) = 0
                %cycle
                    hash value = hash value+(hash value+sym)    { is this good enough? }
                    { add the 4x+1 numbered sym char to the dict }
                    da = da+1; dict(dp) = dict(dp) ! (sym << 8)
                    read sym; %exit %if (symtype >= 0)

                    { add the 4x+2 numbered sym char to the dict }
                    da = da+1; dict(dp) = dict(dp) ! (sym << 16)
                    read sym; %exit %if (symtype >= 0)

                    { add the 4x+3 numbered sym char to the dict }
                    da = da+1; dict(dp) = dict(dp) ! (sym << 24)
                    dp = dp + 1
                    read sym; %exit %if (symtype >= 0)

                    { add the 4x+4 numbered sym char to the dict }
                    da = da+1; dict(dp) = sym
                    read sym; %exit %if (symtype >= 0)
                %repeat
                %if (sym = cquote) %start
                    pend quote = 100
                    ->symbols %if (hash value = 'M')
                    read sym
                    %if (hash value = 'X') %then base = 16 %and ->bxk
                    %if (hash value = 'K') %then base =  8 %and ->bxk
                    %if (hash value = 'O') %then base =  8 %and ->bxk
                    %if (hash value = 'B') %then base =  2 %and ->bxk
                    ->err
                %finish
                { Add the identifier string char count }
                n = da-dbase
                byteinteger(dbase) = n
                { skip over this dict entry if at a 4x+0,4x+1,4x+2 numbered char }
                dp = dmax+1+(n+4)>>2
                abandon(8) %if (dp >= dmin)

                atom2 = 90                              { IDENT }
                %if (last1 = 0) %and (sym = ':') %start { LABEL }
                    limit = local
                    lookup(lab)
                    %return
                %finish
                %if (last1 = jump) %start               { ->label }
                    limit = local
                    lookup(lab+spec+used bit)
                    %return
                %finish
                %if (decl # 0) %and (target = 90) %start    { identifier }
                    search base = fm base
                    limit = local
                    lookup(decl)
                    search base = 0
                %finish %else %start
                    limit = 0
                    lookup(0)
                %finish
            %end { of "code atom" }

            { *opcode_?????????? }
            %predicate parsed machine code
                atom1 = error %and %false %unless (symtype = -2)
                { starts with letter }
                flush buffer %if near buffer limit
                add char( iCodeMCODE )
                %cycle
                    add char( sym )
                    read sym
                %repeat %until (Sym = '_') %or (Symtype = 0)
                { pull in letters and digits }
                add char( '_' )
                %if (symtype # 0) %start
                    { not terminator }
                    read sym
                    %while (symtype # 0) %cycle
                        %if (symtype < 0) %start
                            { complex }
                            code atom(0)
                            %false %if (atom1&error # 0)
                            %if (atom2 = const) %and (type = integer) %start
                                %if (subatom < 0) %then set const(tag(-subatom)_format) %else set const(litpool(subatom))
                            %finish %else %if (91 <= atom1 <= 109) %start
                                %if (atom1 = 104) { label } %and (tag(subatom)_flags&closed = 0) %start
                                    this = subatom
                                    atom1 = error+21
                                    %false
                                %finish
                                add operation(' ', tag(subatom)_index)
                            %finish %else %start
                                atom1 = error
                                %false
                            %finish
                        %finish %else %start
                            sym = sym!128 %if (symtype = 2)
                            { underline with % }
                            add char( sym )
                            read sym
                        %finish
                    %repeat
                %finish
                add char( ';' )
                %true
            %end { of "parsed machine code" }

            %routine Set FTP
                Arp == Ar(Nmax)
                X = Arp_X
                Pos1 = Arp_Pos
                Pos2 = 0
                App  = 0
                Format = Tag(X)_Format
                Flags  = Tag(X)_Flags
                Type   = Flags>>4&7
                Protection = Flags&Prot
                Protection = 0 %if (Flags&Aname # 0)
            %end { of "Set FTP" }

            cont = ' ' %if (gg = 0)
            last1 = 0
            mapgg = 0
            s = 0
            ss = 0
            sstype = -1
            fdef = 0
            fm base = 0
            app = 0

            { deal with alignment following an error in one statement }
            { of several on a line }
            margin = column         { start of statement }
            pos = 0
            strp = gmax+1
            lp = 0
            tbase = tstart          { ?????????????? }
            local = tbase

            %if (gg = 0) %or (ocount >= 0) %start   { data or not continuation(z) }
again:          %while (sym type = 0) %cycle        { skip redundant terminators }
                    c = cont
                    cont = ' '
                    cont = '+' %if (ocount >= 0)
                    read sym
                    cont = c
                %repeat
                ->skip %if (sym = '!')              { comment }
                this = -1
                code atom(0)
                %if (atom1 = comment) %start
skip:               quote = 1
                    c = cont
                    read sym %and cont = c %while (sym # nl)    { skip to end of line }
                    quote = 0
                    symtype = 0
                    ->again
                %finish
            %finish
            decl = 0
            mark = 0
            gentype = 0
            force = 0
            dim = 0
            prot err = 0
            node = 0
            nmax = 0
            nmin = rec size+1
            order = 1
            gmin = max grammar+1
            sstype = 0 %and ->more %if (gg # 0)         { continuation }
            ptype = 0
            spec given = 0

            stats = stats+1
            add operation(iCodeLINE, lines) %if (perm = 0)

            ->fail1 %if (atom1&error # 0)               { first atom faulty }

            %if (escape class # 0) %start
                { enter the hard way after }
                g = imp phrase
                sstype = -1
                ->a3

            %finish

            g = initial(atom1)                      { pick up entry point }
            %if (g = 0) %start                      { invalid first atom }
                g = initial(0)                      { declarator? }
                sstype = 0
                ->a3

            %finish
            %if (g < 0) %start                      { phrase imp }
                g = g&255
                nmax = 1
                ar(1)_class = 0
                ar(1)_link = 0
                ar(1)_sub = imp phrase
            %finish

            gg = gram(g)
            class = gg&255
            sstype = gg>>12&3-1
            ->a1

act(194):   { %SETTYPE [1 - fixing type] }
            ptype = type
            papp = app
            pformat = format
            ->more

act(196):   { %PARAM 10- set parameter type & check] }
            k = g+1
            ->a610

act(188):   { %PTYPE [6 - set phrase type] }
            k = ar(nmax)_sub+1
            ->a610

a610:       papp = glink(k)
            k = gram(k)
            ->more %if (k = 0)          { %name }
            ptype = k&7
            pformat = k>>3
act(183):   { %TYPE [2 - check operand type] }
            k = type
            gentype = k %if (gentype = 0) %or (k = real)
            %if (pformat < 0) %start
                { general type }
                app = papp
                format = pformat
                k = real %if (ptype = real) %and (type = integer)
                k = force %and force = 0 %if (force # 0)
            %finish
            ->fail2 %unless (papp = app) %and ((ptype = k) %or (ptype = 0))
            ->more %if (pformat=format) %or (pformat = 0) %or (format = 0)
            ->fail2

act(197):   { %BLOCK [7 - check block type] }
            arp == ar(nmin)
            k = arp_sub
            ->fail3 %unless (block form = k&15)
            arp_sub = k>>4
            type = block type
            ptype = block type
            pformat = block fm
            papp = app
            pformat = -1 %if (ptype # record)
            ->more

act(195):   { %OPER [8 - check operator type] }
            ->Fail2 %if (Type # 0) %and (Type # integer) %and (Type # Real)
            arp == ar(nmin)
            k = arp_sub
            arp_sub = k>>2
            k = k&3
                                    { 1 = check integer }
                                    { 2 = check real }
                                    { 3 = check real + int }
            ->more %if (k = 0)      { 0 = no action }
            %if (k = 1) %start
                force = integer
                ->more %if (type = integer) %or (type = 0)
                ->fail2

            %finish
            ->fail2 %unless (ptype = real) %or (ptype = 0)  { or added? }
            force = integer %if (k = 3)
            ->more

act(198):   { %OTHER [3,4,9 - sundry others] }
            k = gg>>8&15
            %if (k = 0) %start      { restore atom }
                atom1 = last1
                ->more

            %finish
            %if (k = 1) %start      { test string }
                ->fail2 %unless (type = stringv)
                ->more

            %finish
            %if (k = 2) %start      { fault record comparisons }
                ->fail2 %if (type = record)
                ->more

            %finish
            %if (k = 3) %start      { check OWN variable coming }
                code atom(0)
                ->a7 %if (atom flags&own bit = 0)
                ->more

            %finish
            for warn = pos1 %if (x <= local)    { %for TEST }
            ->more

paction(1): {RECEXP (= 242) check for record exp }
            %if (type = record) %then g = phrase(242) %else pformat = -1
            ->a3

paction(2): { set numerical ptype }
            ptype = real
            pformat = -1
            ->a3

paction(3): { set string type }
            ptype = stringv
            pformat = -1
            ->a3

paction(4): { set integer type }
            ptype = integer
            pformat = -1
            ->a3

paction(5): { set const type }
            ->a3 %if (ptype = integer)
            { 212 RCONST }
            g = phrase(212) %and pformat=-1 %if (ptype = real)
            { 213 SCONST }
            g = phrase(213) %if (ptype = stringv)
            ->a3

paction(6): { set next }
            ptype = gram(ar(nmax)_sub+1)&7
            pformat = -1
            ->a3

paction(7): { generalise cond exps }
            ptype=real %if (ptype = integer)
            pformat = -1
            ->a3

a1:         last1 = class
            atom1 = 0
            s = subatom
a2:         %if (gg&trans bit = 0) %start           { insert into analysis record }
                z == node
                %cycle                              { insert cell in order }
                    k = z
                    %exit %if (gg&order bits = 0) %or (k = 0)
                    gg = gg-order bit
                    z == ar(k)_link
                %repeat
                gg = map gg %if (map gg # 0) %and (gg&255 = var)
                nmin = nmin-1
                ->fail0 %if (nmin = nmax)
                z = nmin
                arp == ar(nmin)
                arp_sub = s
                arp_class = (gg&255)!mark
                arp_link = k
            %finish
            mark = 0
            map gg = 0
            ->more

more:       g = glink(g)                            { chain down the grammar }
paction(0):
a3:         gg = gram(g)
            class = gg&255
            trace analysis %if (diag&1 # 0)
            ->a5 %if (class = 0)                    { end of phrase }

            %if (class < actions) %start            { not a phrase or an action }
                class = atomic(class) %if (class >= figurative)
                ->a2 %if (class >= manifest)
                code atom(class) %if (atom1 = 0)
                %if (escape class # 0) %start       { escape to new grammar }
                    class = escape class
                    escape class = 0
                    g = g+escape

                    { note that following an escape the next item is }
                    { forced to be transparent! }

esc:                gg = 0
                    arp == ar(nmax+1)
                    arp_papp = papp
                    arp_x = x
                    ->a4

                %finish

                ->a1 %if (class = atom1) %or (class = atom2)

a7:             ->fail1 %if (gg >= 0)               { no alternative }
                g = g+1
                ->a3

            %finish

            %if (class >= phrasal) %start           { a phrase }
a4:             nmax = nmax+1
                ->fail0 %if (nmax = nmin)

                arp == ar(nmax)
                arp_ptype = ptype
                arp_pos = pos1
                arp_pformat = pformat
                arp_link = gentype
                arp_class = node
                arp_sub = g
                node = 0
                g = phrase(class)
                ptype = force %and force = 0 %if (force # 0)
                gentype = 0
                ->paction(gg>>8&15)

            %finish
            ->act(class)                            { only actions left }

a5:         { reverse links }
            s = 0
            %while (node # 0) %cycle
                z == ar(node&x'ffff')_link
                k = z
                z = s
                s = node
                node = k
            %repeat
            ss = s
a6:         %if (nmax # 0) %start
                k = gentype                         { type of phrase }
                arp == ar(nmax)
                nmax = nmax-1
                node = arp_class
                gentype = arp_link
                ptype = arp_ptype
                pformat = arp_pformat
                g = arp_sub
                %if (g&escape # 0) %start
                    g = g-escape
                    papp = arp_papp
                    mark = 255
                    subatom = s
                    ->a3

                %finish
                gentype = k %if (gentype = 0) %or (k = real)
                type = gen type

                k = gg                              { exit-point code }
                %cycle
                    gg = gram(g)
                    ->a2 %if (k = 0)
                    ->fail1 %if (gg >= 0)           { no alternative phrase }
                    k = k-order bit
                    g = g+1                         { sideways step }
                %repeat
            %finish

            Fault(4)  %if (copy # 0)
            fault(13) %if (order = 0)
            fault(-4) %if (for warn # 0)
            pos1 = 0
            fault rate = fault rate-1
            %return

act(193):   { %CDUMMY [check = + DUMMY] }
            gg = 0 %and ->a5 %unless (sym = '=') %or (sym = '<')
act(181):   { %DUMMY [set dummy var for init] }
            atom1 = amap(decl&15)
            ->more

act(182):   { %DECL [escape to declarator] }
            class = escdec
            g = glink(g)!escape             { an example of ! as an operator }
            decl = 0
            otype = 0
            ->esc

act(199):   { %COMPILE [compile phrase] }
            s = 0
            %while (node # 0) %cycle
                z == ar(node&x'ffff')_link
                k = z
                z = s
                s = node
                node = k
            %repeat
            ss = s

            code atom(28) %if (quote # 0)   { expend }
            compile
            ->more %if (atom1&error = 0)
            ->fail1

act(184):   { %ZERO [check record=0] }
            ->fail4 %unless (type = integer)
            %if (subatom < 0) %then lit = tag(-subatom)_format %c
                              %else lit = lit pool(subatom)
            ->fail4 %if (lit # 0)
            ->more

act(185):   { %APPLY [apply parameters] }
            s = 0
            %while (node # 0) %cycle
                z == ar(node&x'ffff')_link
                k = z
                z = s
                s = node
                node = k
            %repeat
            ss = s

            atom1 = ar(s)_class
            atom2 = 0
            { 97 = F [function call ]}
            { 98 = M [map call] }
            atom1 = var %if (97 <= atom1 <= 98)
            Set FTP

            %if (flags&subname # 0) %and (format # 0) %start
                ->fail1 %if (format selected = 0)

            %finish
            ->a6

act(187):   { %SETPROT [set protection] }
            protection = prot
            ->more

act(186):   { %PROT [check prot=0] }
            ->more %if (protection&prot = 0)
            prot err = nmin
            ->a7

act(191):   { %GUARD [protect record subnames] }
            k = protection
            code atom(0)
            protection = k %if (atom flags&aname = 0)
            ->more

act(192):   { %MCODE [handle machine code] }
            ->fail1 %unless parsed machine code
            ->more

act(189):   { %GAPP [generate and set app] }
            k = gapp
            delete names(1)
            tmax = tbase
            tbase = gram (gmin)     { restore tmax }
            local= tbase
            gmin = gmin+1

            x = ar(ar(nmax)_class)_sub
            tag(x)_app = k          { update app }
            ->more

act(190):   { %LOCAL [reset local limit] }
            gmin = gmin-1
            abandon(2) %if (gmin <= gmax)
            gram (gmin) = tbase
            tbase = tmax
            local = tbase
            ->more

            { errors }
fail0:      { *too complex }
            k = error+3
            ->failed

fail1:      { ??? }
            k = atom1
            pos2 = 0
            ->failed

fail2:      { *type }
            k = error+5
            pos2 = 0
            ->failed

fail3:      { *context }
            k = error+7
            ->failed

fail4:      { *size }
            k = error+10
            ->failed

failed:     %if (diag&32 # 0) %start
                printstring("Atom1 =")
                write(atom1, 3)
                printstring("  Atom2 =")
                write(atom2, 3)
                printstring("  subatom =")
                write(subatom, 3)
                newline

                printstring("Type =")
                write(type, 1)
                printstring("   Ptype =")
                write(ptype, 1)
                newline

                printstring("App =")
                write(app, 1)
                printstring("   Papp =")
                write(papp, 1)
                newline

                printstring("Format =")
                write(format, 1)
                printstring("   Pformat =")
                write(pformat, 1)
                newline
            %finish

            quote = 0 %and readsym %while (sym # nl) %and (sym # ';')
            %if (k&error # 0) %start
                fault(k&255)
            %finish %else %start
                %if (prot err = nmin) %then fault(14) %else fault(0)
            %finish
            gg = 0
            ss = 0
            symtype = 0
        %end { of "analyse" }

        %routine compile
            %constinteger then = 4, else = 8, loop = 16
            %switch c(0:actions), litop(1:12)

            %constbyteintegerarray operator(1:14) = iCodeLSH,
                                                    iCodeRSH,
                                                    iCodeIEXP,
                                                    iCodeQUOT,
                                                    iCodeAND,
                                                    iCodeOR,
                                                    iCodeXOR,
                                                    iCodeADD,
                                                    iCodeSUB,
                                                    iCodeMUL,
                                                    iCodeDIVIDE,
                                                    iCodeREXP,
                                                    iCodeCONCAT,
                                                    iCodeMOD
            %constbyteintegerarray cc(0:7) = iCodeJNE,
                                             iCodeJE,
                                             iCodeJGE,
                                             iCodeJL,
                                             iCodeJLE,
                                             iCodeJG,
                                             iCodeJZ,
                                             iCodeJNZ
            %constbyteintegerarray anyform(0:15) = 1,0,1(6),0,1,1,0,1(4)
            %constshortintegerarray decmap(0:15) = %c
                      1,       2, x'100B', x'100D', x'140C', x'140E', 3, 4,
                x'1007', x'1008', x'1009', x'100A',       6,       0, 0, 0
            %ownbyteintegerarray cnest(0:15)
            %owninteger last def = 0
            %owninteger lb, ub
            %ownintegerarray pstack(1:40)
            %ownstring(8) name = ""
            %owninteger count = 0
            %record(tagfm)%name t
            %integer lmode, clab, dupid
            %integer resln
            %integer cp, ord
            %integer next, link, j, k, n, done
            %integer class
            %integer lit2, defs, decs, cident
            %integer pending

            %routine def lab(%integer lab)
                add operation(iCodeLOCATE, lab)
                access = 1
            %end { of "def lab" }

            %routine get next
                %record(arfm)%name p

gn:             %if (next = 0) %start                       { end of phrase }
                    class = 0 %and %return %if (link = 0)   { end of statement }
                    p == ar(link)
                    next = p_link
                    link = p_sub
                %finish
                %cycle
                    p == ar(next)
                    x = p_sub
                    class = p_class
                    %exit %if (class < actions)     { an atom }
                    %if (x = 0) %start              { null phrase }
                        next = p_link
                        ->gn

                    %finish
                    %if (p_link # 0) %start         { follow a phrase }
                        p_sub = link
                        link = next
                    %finish
                    next = x
                %repeat
                next = p_link
                %if (diag&2 # 0) %start
                    spaces(8-length(name)) %unless (length(name) = 0)
                    name = text(class)
                    write(x, 2)
                    space
                    printstring(name)
                    space
                    count = count-1
                    %if (count <= 0) %start
                        count = 5
                        name = ""
                        newline
                    %finish
                %finish
            %end { of "get next" }

            { update the app field in n array descriptors }
            %routine set subs(%integer n)
                %integer p

                p = tmax
                %while (n > 0) %cycle
                    tag(p)_app = dimension
                    p = p-1
                    n = n-1
                %repeat
            %end { of "set subs" }

            { define a constant bound pair from the last stacked constants }
            %routine set bp
                pending = pending-2
                lb = pstack(pending+1)
                ub = pstack(pending+2)
                %if (ub-lb+1 < 0) %start
                    pos1 = 0
                    next = link
                    fault(11)
                    ub = lb
                %finish
                set const(lb)
                set const(ub)
                add char(iCodeBOUNDS) %unless (class = 146) { JDM 146 == RCRB?? }
            %end { of "setbp" }

            { type = 0:eof, 1:eop, 2:end }
            %routine compile end(%integer type)
                %if (access # 0) %start
                    open = 0
                    fault(19) %if (block form > proc)   { can reach end }
                %finish

                %while (dict(dmin) >= 0) %cycle         { finishes & repeats }
                    fault(17+dict(dmin)&1)
                    dmin = dmin+1
                %repeat
                add char( iCodeEND )
                add char( iCodeEND ) %if (type = 1)     { endofprogram }

                bflags = bflags!open                    { show if it returns }

                def lab(0) %if (block tag # 0) %and (level # 1) { for jump around }
                %if (type # 2) %start                           { eop, eof }
                    fault(16) %if (level # type)                { end missing }
                %finish %else %if (level = 0) %start
                    fault(15)                           { spurious end }
                %finish

                end mark = 11               { ******Mouses specific****** }
            %end { of "compile end" }

            { dump a descriptor }
            %routine def(%integer p)
                %integer t, f, type
                %record(tagfm)%name v

                flush buffer %if near buffer limit
                defs = defs+1
                v == tag(p)
                t = 0
                %unless (v_index < 0) %start          { no index for subnames }
                    id = id+1 %and v_index = id %if (v_index = 0)
                    last def = v_index
                    t = last def
                %finish
                add operation(iCodeDEF, t)
                add string(get ident(p))              { output the name }
                t = v_flags
                type = t
                type = type&(\(7<<4)) %if (type&(7<<4) >= 6<<4) { routine & pred }
                append tag(type&b'1111111')                     { type & form }
                f = v_format
                f = tag(f)_index %if (t&x'70' = record<<4)
                f = v_index %if (f < 0)
                append tag(f)                   { format }
                f = otype+t>>4&b'1111000'
                f = f!8 %if (class = 125)       { add spec from %DUP }
                dim = v_app                     { dimension }
                dim = 0 %unless (0 < dim <= dim limit)
                append tag(f+dim<<8)            { otype & spec & prot }
                defs = 0 %if (t&parameters = 0)
                f = t&15
                %if (v_flags&spec # 0) %start
                    v_flags = v_flags&(\spec) %unless (3 <= f <= 10)
                    ocount = -1             { external specs have no constants }
                %finish
                dimension = 0
                %if (otype = 2) %and ((f=2) %or (f=12) %or (f=14)) %start
                    v_flags = v_flags-1     { convert to simple }
                %finish
            %end { of "def" }

            { define a switch label, x defines the switch tag }
            %routine def s lab(%integer n)
                %integer p, l, b, w, bit

                p = tag(x)_format           { pointer to table }
                l = dict(p)                 { lower bound }
                %if (l <= n <= dict(p+1)) %start
                    b = n-l
                    w = b>>4+p
                    bit = 1<<(b&15)
                    %if (dict(w+2)&bit # 0) %start  { already set }
                        fault(4) %if (pending # 0)
                        %return
                    %finish
                    dict(w+2) = dict(w+2)!bit %if (pending # 0)
                    set const(n)
                    add operation(iCodeSLABEL, tag(x)_index)   
                %finish %else %start
                    fault(12)
                %finish
                access = 1
            %end { of "def s lab" }

            %routine call
                %record(tagfm)%name T

                t == tag(x)
                add operation(iCodePUSH, t_index)
                access = 0 %if (t_flags&closed # 0)     { never comes back }
                add char( iCodeCALL ) %if (t_app = 0)   { no parameters }
            %end { of "call" }

            %routine pop def
                set const(pstack(pending))
                pending = pending-1
            %end { of "pop def" }

            %routine pop lit
                %if (pending = 0) %then lit = 0 %else %start
                    lit = pstack(pending)
                    pending = pending-1
                %finish
            %end { of "pop lit" }

            %routine push(%integer x)
                %if (cnest(cp)&2 # x) %start
                    cnest(cp) = cnest(cp)!1
                    x = x+4
                %finish
                clab = clab+1 %if (cnest(cp)&1 # 0)
                cnest(cp+1) = x
                cp = cp+1
            %end { of "push" }

            %routine pop label(%integer mode)
                lmode = dict(dmin)
                %if (lmode < 0) %or (lmode&1 # mode) %start
                    fault(mode+8)
                %finish %else %start
                    dmin = dmin+1
                    label = label-3
                %finish
            %end { of "pop label" }

            %if (sstype < 0) %start         { executable statement }
                %if (level = 0) %start      { outermost level }
                    fault(13)               { *order }
                %finish %else %start
                    %if (access = 0) %start
                        access = 1
                        fault(-1)           { only a warning }
                    %finish
                %finish
            %finish

            %if (diag&2 # 0) %start
                newline %if (sym # nl)
                printstring("ss =")
                write(ss, 1)
                newline
                count = 5
                name = ""
            %finish

            next = ss
            pending = 0
            lmode = 0
            link = 0
            decs = 0
            defs = 0
            resln = 0
            done = 0
            ord = level
            ord = 1 %if (this >= 0)     { recordformat declarations }
c(0):
top:        %if (next # link) %start
                get next
                ->c(class)
            %finish

            { all done, tidy up declarations and jumps }
            newline %if (diag&2 # 0) %and (count # 5)

            %if (lmode&(loop!then!else) # 0) %start                         { pending labels and jumps }
                add operation(iCodeREPEAT, label-1) %if (lmode&loop # 0)    { repeat }
                def lab(label)   %if (lmode&then # 0)                       { entry from then }
                def lab(label-1) %if (lmode&else # 0)                       { entry from else }
            %finish

            %return %if (decs = 0)
            atom1 = error %and %return %if (atom1 # 0)      { %integerroutine }
            order = ord
            decl = decl&(\15)+decmap(decl&15)       { construct declarator flags }
            atom1 = atoms(decl&15)                  { generate class }
            %if (otype # 0) %start                  { own, const etc. }
                atom1 = atom1+1 %if (atom1 # proc)
                %if (otype = 2) %start              { const }
                    n = decl&15
                    %if (n&1 # 0) %start
                        decl = decl!prot
                        decl = decl!const bit %if (decl&b'1111111' = iform)
                    %finish
                %else
                    decl = decl!own bit
                %finish
            %finish
            sstype = 1 %if (sstype = 0) %and (atom1 = proc)
            atom1 = atom1+1 %if (decl&spec # 0)         { onto spec variant }
            ocount = 0 %and cont = '+' %if (atom1 = 5)  { own array }
            %if (anyform(decl&15) = 0) %start           { check meaningful }
                %if (decl>>4&7 = record) %start
                    this = fdef %if (tag(fdef)_flags&spec # 0)
                    atom1 = error+21 %if (fdef = this)  { *context for format }
                %finish
                atom1 = error+10 %if (fdef = 0)         { *size }
            %finish
            %return

atop:       access = 0
            ->top

            { declarators }
c(88):      { RTYPE }
c(28):      { STYPE }
            decl = x&(\7)
            fdef = x&7                                      { precision }
            fdef = reals ln %if (x&b'1110001' = real<<4+1)  { convert to long }
            decs = 1
            ->top

c(34):      { OWN }
c(35):      { EXTERNAL }
            otype = x
            ord = 1
            ->top

c(152):     { XNAME }
            decl = decl+x<<1
            ->top

c(31):      { PROCD }
c(32):      { FNMAP }
            spec mode = level+1             { fn/map }
            decl = decl!prot %if (x = 9)    { function }
c(29):      { ARRAY }
            ord = 1
            dim = 0
c(30):      { NAME }
            decl = decl+x
            decs = 1
            ->top

c(27):      { ARRAYD }
            lit = 0
            %if (pending # 0) %start
                pop lit
                %unless (0<lit<=dim limit) %start
                    atom1 = error + 11
                    %return
                %finish
            %finish
            dim = lit
            decl = decl + x
            decs = 1
            -> top

c(37):      { RECORD }
            x = x!subname
c(36):      { STRING }
            lit = 0
            %if (pending # 0) %start
                pop lit
                %unless (0 < lit <= 255) %start       { max length wrong }
                    atom1 = error+10
                    %return
                %finish
            %finish
            fdef = lit                              { format or length }
c(33):      { SWITCH }
            decl = x
            decs = 1
            ->top

c(39):      { SPEC }
            decl = decl!spec
            ocount = -1                             { no initialisation }
            spec mode = -1
            ->top

c(38):      { FORMAT }
            decl = 64+4
            order = 1
            atom1 = x
            decl = decl!spec %if (atom1 = 12)       { formatspec }
            fdef = tmax+1                           { format tag }
            %return

c(175):     { FSID }
            id = id+1
            tag(x)_index = id
            %return

c(41):      { LABEL }
            decs = 1
            decl = x!spec!closed
            ->top

c(133):     { FNAME }
            recid = 0
            rbase = tmin-1
            this = x
            fm base = fdef
            format list = tmin
            def(this)
            ->top

c(148):     { RECLB }
            fdef = 0 %and ->top %if (next = 0)
            get next                                { skip name }
            fdef = x
            ->top

c(127):     { %POUT [end   of parameters] }
            add char( iCodeFINISH )
            ->top

c(126):     { %PIN [start of parameters] }
            add char( iCodeSTART )
            ->top

c(174):     { RANGERB }
            set bp
c(171):     { FMLB }
c(172):     { FMRB }
c(173):     { FMOR }
            add char( iCodeALT )
            add char( class-171+'A' )
            ->top

c(168):     { ORRB }
            rbase = -rbase
            sstype = 0
            spec mode = 0
c(147):     { RECRB }
            search base = 0
            tag(this)_app = tmin
            tag(this)_format = rbase
            ->top

c(45):      { SIGN }
            add char( iCodeNEGATE ) %if (x = 36)
            ->top

c(46):      { UOP }
            add char( iCodeNOT )
            ->top

c(47):      { MOD }
c(48):      { DOT }
c(42):      { OP1 }
c(43):      { OP2 }
c(44):      { OP3 }
            add char( operator(x) )
            ->top

            { conditions & jumps }
c(56):      { AND }
c(57):      { OR }
            push(x)
            ->top

c(58):      { NOT }
            cnest(cp) = cnest(cp)!!2
            ->top

c(138):     { CSEP: treat like %while NB. CSEP=138 }
            x = b'10110100'
c(59):      { WHILE }
c(60):      { UNTIL }
            %if (class = 138) %then add operation(iCodeFOR, label-1) %else def lab(label-1)
c(166):     { RUNTIL }
c(62):      { CWORD }
            lmode = (lmode&(else!loop)) !(x>>3)
            clab = label
            cp = 1
            cnest(1) = x&7
            ->top

c(72):      { REPEAT }
            pop label(0)
            def lab(label+1) %if (lmode&32 # 0)
            ->atop

c(69):      { FINISH }
            pop label(1)
            ->top

c(163):     { XELSE }
c(70):      { FELSE }
            pop label(1)
            fault(7) %if (lmode&3 = 3)      { dangling else }
c(68):      { ELSE }
            lmode = (lmode&else)!3
            %if (access # 0) %start
                add operation(iCodeGOTO, label-1)
                lmode = else!3
            %finish
            def lab(label)
            ->top %if next # 0

c(120):     { %MSTART [infiltrate %start] }
c(67):      { START }
c(71):      { CYCLE }
            -> stcy

stcy:       def lab(label-1) %and lmode = loop %if (lmode = 0) { cycle }
            dmin = dmin-1
            abandon(3) %if (dmin <= dmax)
            dict(dmin) = lmode
            label = label+3
            %return

c(64):      { ON event }
            fault(13) %if dict(dmin) >= 0 %or inhibit # 0
            inhibit = 1
            n = 0
            n = x'FFFF' %if (pending = 0)                 { * = all events }
            %while (pending > 0) %cycle
                pop lit
                fault(10) %if (lit&(\15) # 0)     { too big }
                j = 1<<lit
                dubious = 1 %if (n&j # 0)
                n = n!j                         { construct bit mask }
            %repeat
            add operation(iCodeON, n)
            Append Tag(label)
            lmode = then!1
            ->stcy

c(104):     { L [label] }
            add operation(iCodeJUMP, tag(x)_index)
            inhibit = 1
            ->atop

c(149):     { LAB }
            stats = stats-1
            access = 1
            inhibit = 1
            add operation(iCodeLABEL, tag(x)_index)
            ->top

c(63):      { EXIT }
            j = dmin
            labxx = label-3
            %cycle
                fault(7) %and ->top %if (dict(j) < 0)
                %exit %if (dict(j)&1 = 0)
                j = j+1
                labxx = labxx-3
            %repeat
            labxx = labxx+1 %if (x = 32)    { continue }
            add operation(iCodeGOTO, labxx)
            dict(j) = dict(j)!x             { show given }
            ->atop

c(50):      { ACOMP }
            add char( iCodeCOMPAREA )
            ->cop

c(49):      { COMP }
            %if (next # 0) %start             { comparator }
                add char( iCodeCOMPARED )
                push(0)                         { double sided }
            %finish %else %start
                add char( iCodeCOMPARE )
            %finish
            ->cop

cop:        { invert the condition }
            x = x!!1 %if (cnest(cp)&2 # 0)
            j = cp
            labxx = clab
            %while (cnest(j)&4 = 0) %cycle
                j = j-1
                labxx = labxx-cnest(j)&1
            %repeat
            add operation(cc(x), labxx)
            def lab(clab+1) %if (cnest(cp)&1 # 0)
            cp = cp-1
            clab = clab-cnest(cp)&1
            ->top

c(78):      { FRESULT }
c(79):      { MRESULT }
c(80):      { BACK ==return, true, false }
            open = 0
            access = 0
c(89):      { ADDOP }
c(81):      { MONITOR }
            add char( x )
            ->top

c(82):      { STOP }
c(65):      { SIGNAL }
            pop lit
            add operation(iCodeEVENT, lit)
            fault(10) %unless (0 <= lit <= 15)
            ->atop

c(51):      { EQ }
            add char( iCodeASSVAL )
            ->top

c(53):      { JAM }
            add char( iCodeJAM )
            ->top

c(52):      { EQEQ }
            add char( iCodeASSREF )
            ->top

c(74):      { BEGIN }
            %if (level = 0) %start
                %if (progmode <= 0) %then progmode = 1 %else fault(7)
                { Permit BEGIN after external defs }
            %finish
            spec mode = level+1
            block x = 0
            add char( iCodeBEGIN )
            %return

c(77):      { ENDPERM }
            perm = 0
            lines = 0
            stats = 0
            close input
            select input(source)
            list = list-1
            tbase = tmax
            tstart = tmax
            %return

c(76):      { ENDPROG }
            %if (include # 0) %and (x = 0) %start
                lines = include
                sstype =  0         { include }
                close input
                list = include list
                include level = 0
                include = 0
                select input(source)
                %return
            %finish
            ss = -1             { prog/file }
c(75):      { END }
            compile end(x)
            %return

c(85):      { CONTROL }
            %if (x=0) %start
                { control }
                control=lit
                add operation(iCodeCONTROL, lit)
            %finish %else %start
                { diagnose }
                diag = lit&x'3FFF' %if (lit>>14&3 = 1)
                add operation(iCodeDIAG, lit)
            %finish
            ->top

c(83):      { LIST }
            list = list+x-2
            ->top

c(84):      { REALSLN }
            reals ln = x
            ->top

c(86):      { INCLUDE }
            %if (include # 0) %start
                fault(7)
                %return
            %finish
            get next        { should be a string constant }

            x = x-x'4000'
            j = glink(x)
            k = j&255
            { ABD - another little copy loop because SKIMP can't do the string map }
            include file = ""
            %cycle
                k = k - 1
                %exit %if (k < 0)
                include file = include file.tostring(j>>8)

                x = x + 1
                j = glink(x)

                k = k - 1
                %exit %if (k < 0)
                include file = include file.tostring(j&255)
            %repeat

            include file = actual include("",include file)
            %begin
                { remove this event block for SKIMP or pre-event IMP versions }
                %on 9 %start
                    Abandon(9)
                %finish

                open input(3, include file)
            %end
            include = lines
            lines = 0
            include list = list
            include level = level
            select input(3)
            ->top

c(154):     { DBSEP }
            dimension = dimension+1
            fault(11) %if (dimension = dim limit+1)
            ->top

c(145):     { CRB }
            set bp
            ->top

c(146):     { RCRB }
            set bp
c(142):     { BPLRB }
            dimension = 1 %if (dimension = 0)
            add operation(iCodeDIM, dimension)
            Append Tag(defs)
            %if (class # 146) %start
                set subs(defs)
                fault(13) %if (dict(dmin) >= 0) %or (inhibit # 0) %or (level=0)
            %finish
            dimension = 0
            defs = 0
            ->top

c(128):     { %EDUP [end of DUP] }
            id = dupid
            ->top

c(130):     { PIDENT }
            block x = x
            add operation(iCodeGOTO, 0) %if (decl&spec = 0) %and (level # 0)   { jump round proc }
c(125):     { %DUP [duplicate proc param id] }
            dupid = id
            %return %if (Level < 0)       { spec about }
c(90):      { IDENT [identifier] }
            def(x)
            ->top

c(131):     { CIDENT }
            t == tag(x)
            %if (t_flags&(b'1111111'+const bit) = iform+const bit) %start
                t_format = lit
            %finish %else %start
                set const(lit) %if (pending # 0)
                def(x)
                add operation(iCodeINIT, 1)
            %finish
            cident = x
            ->top

c(124):     { %DUBIOUS [check dubious declaration] }
            dubious = 1 %if (tag(cident)_flags&prot # 0)
            ->top

c(96):      { R [routine call] }
c(97):      { F [function call] }
c(98):      { M [map call] }
c(99):      { P [predicate call] }
            call
            ->top

c(91):      { V   [simple variable] }
c(92):      { N   [pointer variable] }
c(100):     { RP  [routine parameter] }
c(101):     { FP  [function parameter] }
c(102):     { MP  [map parameter] }
c(103):     { PP  [predicate parameter] }
c(106):     { A   [array]}
c(107):     { AN  [arrayname]}
c(108):     { NA  [name array]}
c(109):     { NAN [namearrayname]}
c(165):     { NLAB }
            k = tag(x)_index
            %if (k < 0) %start
                add operation(iCodeSELECT, -k)
            %finish %else %start
                add operation(iCodePUSH, k)

                { Check if this push is for an array }
                %if (tag(x)_flags&15 = 11) %start
                    { It is a push of an array variable }
                    { So push the array data onto the array reference stack }
                    aref count = aref count + 1
                    %if (1 <= aref count <= aref max ) %start
                        s == aref(aref count)
                        s_name = get ident ( x )
                        s_flags  = tag(x)_flags
                        s_format = tag(x)_format
                        s_index = tag(x)_index
                    %finish
                %finish
            %finish
            ->top

c(121):     { %CLEAR [record=0] }
            { special for zero }
            set const(0)
            ->top

c(167):     { ACONST }
            { alias constant }
            add char( iCodeALIAS )

xconst:     { store a string }
            x = x-x'4000'
            j = glink(x)
            k = j&255
            add char( k )
            %cycle
                k = k - 1
                %exit %if k < 0
                add char( j>>8 )

                x = x + 1
                j = glink(x)

                k = k - 1
                %exit %if k < 0
                add char( j&255 )
            %repeat
            ->top

c(const):   { CONST [constant] ==93 }
            %if (x < 0) %start                            { constinteger }
                set const(tag(-x)_format)
            %finish %else %if (x&x'4000' # 0) %start      { strings }
                add char( iCodePUSHS )
                ->xconst
            %finish %else %if (x&x'2000' # 0) %start    { real }
                { real - ABD also string-like, but NOT packed }
                x = x-x'2000'

                k = glink(x)
                add operation(iCodePUSHR, k)
                add char( ',' )
                %cycle
                    k = k - 1
                    %exit %if (k < 0)

                    x = x + 1
                    j = glink(x)
                    { have we found the '@' scale factor for the real number? }
                    %if (j = '@') %start
                        { glink(x+1) points to the exponent }
                        { an integer value in the lit pool() }
                        { get the pointer to the litpool() entry }
                        { DANGER glink() is a %shortarray }
                        { iCode ACCESS understands %byte and %short index values }
                        { %byte value zero extended to an %integer index value }
                        { %short value sign-extended to an %integer index value }
                        add operation('@', litpool(glink(x+1)))

                        %exit
                    %finish %else add char( j )
                %repeat
            %finish %else %start
                set const(lit pool(x))
            %finish
            ->top

c(137):     { ASEP }
            add char( iCodeINDEX )
            ->top

c(141):     { ARB }
            { pop the array reference }
            aref count = aref count - 1
            add char( iCodeACCESS )
            ->top

            { own arrays }
c(132):     { OIDENT }
            ocount = ub-lb+1
            def(x)
            dimension = 1
            set subs(1)
            %if (next = 0) %start     { no initialisation }
                add operation(iCodeINIT, ocount) %if (ocount > 0)
                ocount = -1
            %finish %else %start    { initialisation given }
                get next
            %finish
            flush buffer %if near buffer limit
            ->top

c(162):     { INDEF }
            lit = ocount
            ->ins

c(143):     { ORB }
            pop lit
            ->ins

c(139):     { OSEP (x=19) }
c(153):     { OWNT }
            lit = 1
            ->inst

ins:        fault(10) %and lit = 0 %if (lit < 0)
            get next
            ->inst

inst:       pop def %if (pending # 0)     { OWNT (x=0) }
            add operation(iCodeINIT, lit)
            ocount = ocount-lit
            %if (ocount >= 0) %start
                ->top %if (x # 0)         { more coming }
                ocount = -1 %and %return %if (ocount = 0) { all done }
            %finish
            fault(11)
            %return

c(swit):    { S [switch] ==105 }
            add operation(iCodeSJUMP, tag(x)_index)
            inhibit = 1
            ->atop

c(134):     { SWID }
            def(x)
            n = ub-lb+1
            n = (n+15)>>4               { slots needed (includes zero) }
            j = dmax
            dmax = dmax+n+2
            abandon(1) %if (dmax >= dmin)
            tag(x)_format = j
            dict(j) = lb
            dict(j+1) = ub
            %cycle
                n = n-1
                %exit %if (n < 0)
                j = j+1
                dict(j+1) = 0
            %repeat
            ->top

c(151):     { SLAB }
            stats = stats-1
            fault(7) %and %return %if (x < tbase)
            %if (pending # 0) %start      { explicit label }
                def s lab(pstack(1))
            %finish %else %start
                fault(4) %and %return %if (tag(x)_app # 0)
                tag(x)_app = 1
                n = tag(x)_format
                %for j = dict(n), 1, dict(n+1) %cycle
                    def s lab(j)
                    flush buffer %if near buffer limit
                %repeat
            %finish
            inhibit = 1
            %return

c(140):     { PSEP }
            add char( iCodeASSPAR )
            ->top

c(144):     { PRB }
            add char( iCodeASSPAR )
            add char( iCodeCALL )
            ->top

            { constant expressions }
c(155):     { PCONST }
            %if (x < 0) %then lit = tag(-x)_format %else lit = lit pool(x)
            pending = pending+1
            ->SetLit

c(156):     { CMOD }
            lit = pstack(pending)
            lit = -lit %if lit < 0
            ->SetLit

c(157):     { CSIGN }
            lit = -pstack(pending)
            ->SetLit

c(158):     { CUOP }
            lit = \pstack(pending)
            ->SetLit

c(159):     { COP1 }
c(160):     { COP2 }
c(161):     { COP3 }
            pending = pending-1
            lit = pstack(pending)
            lit2 = pstack(pending+1)
            ->litop(x>>2)

c(170):     { OSTRING }
            !Fault(4) %if IMPCOM_Option # ""
            !IMPCOM_Option = String(x-x'4000'+Stbase); ! Option string
            ->top

            { string resolution }
c(135):     { DOTL }
            resln = 2
            ->top

c(136):     { DOTR }
            resln = resln+1
            ->top

c(55):      { RESOP }
            add operation(iCodeRESOLVE, resln)
            resln = 0
            ->top

c(164):     { CRESOP }
            add operation(iCodeRESOLVE, resln+4)
            resln = 0
c(122):     { %PRED [set cc from predicate] }
            x = 6
            ->cop

c(87):      { MASS }
            set const(pstack(1))
            add char(iCodePLANT)
            ->top

litop(1):   lit = lit<<lit2
            ->SetLit

litop(2):   lit = lit>>lit2
            ->SetLit

litop(3):   { evaluating lit = lit\\lit2 }
            n = 1
            fault(10) %if (lit2 < 0)
            lit2 = lit2-1 %and n = n*lit %while (lit2 > 0)
            lit = n
            ->SetLit

litop(4):   %if (lit2 = 0) %then fault(10) %else lit = lit//lit2
            ->SetLit

litop(5):   lit = lit&lit2
            ->SetLit

litop(6):   lit = lit!lit2
            ->SetLit

litop(7):   lit = lit!!lit2
            ->SetLit

litop(8):   lit = lit+lit2
            ->SetLit

litop(9):   lit = lit-lit2
            ->SetLit

litop(10):  lit = lit*lit2
            ->SetLit

litop(11):  %if (lit2 = 0) %then fault(10) %else lit = lit//lit2
            ->SetLit

litop(12):  { evaluating lit = lit\\lit2 }
            n = 1
            fault(10) %if (lit2 < 0)
            lit2 = lit2-1 %and n = n*lit %while (lit2 > 0)
            lit = n
            ->SetLit

SetLit:     pstack(pending) = lit
            ->top

        %end { of "compile" }

        dmin = dmin-1
        dict(dmin) = -1     { end marker for starts & cycles }
        abandon(2) %if (dmax = dmin)

        %if (list > 0) %and (quiet = 0) %and (level > 0) %start
            write(lines, 5)
            spaces(level*3-1)
            %if (block tag = 0) %start
                printstring("Begin")
            %finish %else %start
                printstring("Procedure ".get ident(block tag))
            %finish
            newline
        %finish

        { deal with procedure definition (parameters) }
        %if (block tag # 0) %start    { proc }
            analyse
            compile %if (ss # 0)

            %if (block otype # 0) %start          { external-ish }
                %if (bflags&spec = 0) %start      { definition }
                    %if (progmode <= 0) %and (level = 1) %then progmode = -1 %else fault(7)
                %finish
            %finish

            new app = gapp                            { generate app grammar }
            %if (spec given # 0) %start               { definition after spec }
                fault(6) %if (new app # block app)    { different from spec }
            %finish
            block app = new app                 { use the latest }

            %if (level < 0) %start                { not procedure definition }
                delete names(0)
                %return

            %finish
        %finish %else %start
            open = 0                            { can return from a block? }
        %finish

        %cycle
            analyse
            %continue %if (ss = 0)
            compile
            fault(-5) %if (dubious # 0)
            flush buffer %if near buffer limit
            %if sstype > 0 %start           { block in or out }
                %exit %if (sstype = 2)      { out }
                compile block(spec mode, block x, dmin, tmax, id)
                %exit %if (ss < 0)          { endofprogram }
            %finish
        %repeat
        %if (list > 0) %and (quiet = 0) %and (level > 0) %start
            write(lines, 5)
            spaces(level*3-1)
            printstring("End")
            newline
        %finish
        delete names(0)
        %return

    %end { of "compile block" }

    { Start of top level code for pass1 routine }
    %on 9 %start
        abandon(5)
    %finish

    { initialise the I/O streams }
    Tty  =  1                %if (Options&LL Report = 0)
    select input(2)
    select output(listing)
    tag(max tag) = 0                        { %begin defn }
    tag(0) = 0
    tag(0)_flags = 7                        { %begin tag! }
    hash(x) = 0 %for x = 0, 1, max names
    printstring("         Edinburgh IMP77 Compiler - Version ")
    printstring(P1 Version)
    newlines(2)

    hash(x) = 0 %for x = 0, 1, max names
    add operation(iCodeLANG, 0)
    compile block(0, 0, max dict, 0, 0)
    add char(iCodeEOF)                    { for bouncing off }
    flush buffer
    No Stats = stats
    No Faults = faulty

    x = listing
    newline
    %if (Options&LL Mon # 0) %start
        Select Output(report)
        printstring("Tags: ")
!        write(Tag Lower, 0)
        write(Tmin, 1)
        newline

        printstring("Dict: ")
        write(Dmax, 0)
!        write(Dict Upper, 1)
        newline

        printstring("Gram: ")
        write(Gmax, 0)
        write(Gmin, 1)
        newline
    %finish

    %cycle
        %if (faulty = 0) %start
            write(stats, 5)
            printstring(" Statements compiled")
        %else
            printstring(" Program contains ")
            write(faulty, 1)
            printstring(" fault")
            printsymbol('s') %unless faulty = 1
        %finish
        newline
        %exit %if x = report
        x = report
        selectoutput(report)
    %repeat

%end { of "pass1" }
%endoffile
