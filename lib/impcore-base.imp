{-----------------------------------------------------------------------------}

    !
    ! We ass-u-me that:
    ! (1) the processor is byte addressable
    ! (2) an address is 32-bits (=4 bytes)
    !

    %include "impcore.types.inc"

    !--------------------------------------------------------------------------
    ! Calculated array properties
    !--------------------------------------------------------------------------
    !--------------------------------------------------------------------------
    ! Given a dope vector:
    ! (1) calculate the offset (in bytes) of the highest element
    ! (2) calculate the offset from A(0,...,0) of the first element
    ! - the size of the store to allocate is therefore the difference.
    ! We return the two 32 bit answers as one result
    !     => "high" answer is in DX
    !     => "low" answer is in AX.
    ! Thus DX contains the top, AX the A(0) offset
    ! The way we achieve this is compiler dependent,
    ! so we declare this as VOID and then do the return in-line
    !--------------------------------------------------------------------------
    %external %routine impadef ( %integer %name dvp )
        %integer lb,lbAddress, ub,ubAddress, sz,szAddress
        %integer i, dim, base, limit, row

        ! The count of array dimensions is located at addr(dvp)
        dim = dvp

        ! the element size is given after the last pair of lower,upper bounds
        szAddress = addr(dvp) + addressSize*(2*dim + 1)

        ! initialise the base "address" and limit "address"
        base = 0
        limit = 0

        ! General case iterates backwards toward first dimension
        ! last dim upper bound is just before the szAddress
        ubAddress = szAddress - addressSize
        ! a lower bound is always just before the upper bound
        lbAddress = ubAddress - addressSize

        ! Now, iterate over each pair of a dimensions bounds
        %for i=1,1,dim %cycle
            ! NB. at i=1, we point to the rightmost dimensions lower,upper bounds
            lb = integer( lbAddress )
            ub = integer( ubAddress )

            ! we declare array bounds so that lb <= ub
            ! so, check that the bounds obey that rule!
            %signal 5, 3, 0 %unless lb <= ub

            ! calculate the number of objects in a row
            ! NB we add one to avoid the fence post error
            row   = (ub - lb) + 1
            base  = base * row + lb
            limit = limit * row + ub

            ! now point to the lower, upper bounds of the next lower array dimension
            ubAddress = lbAddress - addressSize
            lbAddress = ubAddress - addressSize
        %repeat

        ! Get the size/type descriptor
        sz = integer( szAddress )

        ! finally get the size of each array element
        sz = (sz>>5)

        base = base * sz
        limit = (limit + 1) * sz

        *mov_ %edx,limit
        *mov_ %eax,base

        %return
    %end { of "impadef" }

    !--------------------------------------------------------------------------
    ! Array Reference function.
    !
    ! Array indices are pushed left to right so we get them right to left.
    ! The last thing pushed is a pointer to the Dope Vector.
    !
    ! We need to fiddle with addresses because this function has a 
    ! variable parameter count.
    !
    ! This parameter count depends on the number of dimensions in the array
    ! The IMP parameters are stacked, so need to access in reverse order
    ! Even worse, there are a variable number of index values
    !    (One index value for each array index)
    ! We pretend there are no stacked parameters in the function declaration
    ! Fortunately the "last" IMP parameter (the DVP) can be used to calculate
    ! the expected parameter count.
    ! We actually access parameters via the "ebp" register
    !                                      (=Base/Frame pointer)
    ! Now assuming integer size = 4 byte
    ! Remember [ebp]         = framep
    !          [ebp+4]       = return address
    !          [ebp+8]       = dope vector address (DVP)
    !          [ebp+12]      = last array index = dim'th index value
    !          [ebp+8+dim*4] = 1st array index = 1st index value
    ! The function result is the offset that needs to be added to the
    ! notional A(0,0,0) address to get the variable in the array
    !
    ! IMP declaration
    ! %external %integer %function imparef(%integer i1 {.. idim},
    !                                      %integer %name dvp)
    !
    ! Hence, the above mentioned contortions to deal with a variable count
    ! of parameters.
    ! Fortunately, the "last" parameter stacked (the dopevector address)
    ! gives a clue as to the actual count of parameters.
    !
    ! Luckily, the IMP compiler "pops" the set of parameters on return from
    ! this routine call.
    ! Thus we can "pretend" this routine is declared with no parameters.
    ! However we need to use a bit of embedded machine code to access the
    ! actual parameters via the frame pointer
    !--------------------------------------------------------------------------
    %external %integer %function imparef
        %integer framep
        %integer %name dvp
        %integer dvpAddress, indexAddress
        %integer szAddress, lbAddress, ubAddress
        %integer dim, sz, lb, ub, index
        %integer row, result
        %integer i

        ! Get the Base/Frame Pointer
        *mov_ framep,%ebp

        ! IMP does NOT allow routines with a variable number of parameters
        ! but we need 
        ! parameter         1) dope vector address
        ! parameters 2..dim+1) array index values (dim = array dimensionality)

        ! Now get various data items from the dope vector
        ! The "last" parameter stacked is the pointer to dope vector
        ! Get the dope vector address
        !     ("last" C parameter/"first" IMP parameter)
        ! skip over the 'old' FramePointer and the routine's ReturnAddress
        ! on the stack
        dvpAddress = framep + 2*addressSize
        dvp == integer( integer( dvpAddress ) )

        ! get the address of the last array index
        ! remember the index values are stacked in reverse order
        ! The last shall be first!!!
        indexAddress = dvpAddress + addressSize

        ! Now get the array dimensionality from the dope vector
        dim = dvp

        ! Now get the address of the size of each array element
        szAddress = addr(dvp) + addressSize*(2*dim + 1)

        ! get the address of the last upper bound
        ! placed just before the location of the array element size
        ubAddress = szAddress - addressSize
        ! and the address of it's associated lower bound
        lbAddress = ubAddress - addressSize

        ! General case iterates backwards toward first dimension
        ! For a general number of dimensions, 1 or more
        ! we do this the hard way...
        ! result so far
        result = 0
        ! at i=1, we start with the rightmost bounds
        ! their addresses have been pre-calculated 
        %for i=1,1,dim %cycle

            lb = integer( lbAddress )
            ub = integer( ubAddress )

            ! Get the index: at i=0, point to the rightmost array index
            index = integer( indexAddress )

            ! Check the index to see if index in range lb:ub
            %signal 6, 2, index %unless (lb <= index <= ub)

            ! calculate the number of objects in a row
            row   = (ub - lb) + 1

            ! accumulate this index count
            result = (result * row) + index

            ! update the lb,ub,index addresses
            ! get the previous upper bound address
            ubAddress = lbAddress - addressSize
            ! get it's associated lower bound address
            lbAddress = ubAddress - addressSize
            ! hop to the next lower index address
            ! NB the index values are in reverse order
            indexAddress = indexAddress + addressSize
        %repeat

        ! Get the size/type descriptor
        sz = integer( szAddress )

        ! finally get the size of each array element
        sz = (sz>>5)

        ! multiply the accumulated count by element size
        %result = result * sz
    %end { of "imparef" }

    !--------------------------------------------------------------------------
    ! Returns floating point x ^ p
    !--------------------------------------------------------------------------
    %external %long %real %function impfexp ( %integer p, %long %real x)
        %long %real r;

        %if (p = 0) %then %result = 1.0
        %if (x = 0.0) %then %result = 0.0

        ! deal with negative exponents
        %if (p < 0) %start
            x = 1.0/x
            p = -p
        %finish

        r = 1.0
        %cycle
            %if ((p & 1) # 0) %then r = r * x;
            p = p >> 1;
            %if (p = 0) %then %result = r;
            x = x * x;
        %repeat
    %end { of "impfexp" }

    !--------------------------------------------------------------------------
    ! returns x ^ y
    !--------------------------------------------------------------------------
    %external %integer %function impiexp ( %integer y, x)
        %integer value;

        %signal 5, 2, y %unless (y >=0);

        value = 1;

        %while (y > 0) %cycle
            value = value * x
            y = y - 1
        %repeat

        %result = value
    %end { of "impiexp" }

    {--------------------------------------------------------------------------}
    %external %routine impstrcat ( %byte %name dst, src, %integer len)
        %integer i
        %integer count
        %byte dlen,slen
        %byte %name srcx,dstx

        %if (len = 0) %then len = MAXSTRINGLEN; ! string(*)name - comes from general %name's etc

        dlen = dst;   ! pick up existing destination length
        slen = src;   ! fetch the source length

        %signal 6,1,1 %if (slen + dlen > len)

        count = slen
        dlen = dlen + count

        ! update the destination count
        dstx == byteinteger( addr( dst) ); ! get the address
        dstx = dlen;                       ! set the new length

        ! copy across the source chars
        %for i = 1,1,count %cycle
            srcx == byteinteger( addr(src) + i )
            dstx == byteinteger( addr(dst) + (dlen - count) + i )
            dstx = srcx
        %repeat
    %end { of "impstrcat" }

    {--------------------------------------------------------------------------}
    ! strcmp returns a number comparable to the state of the
    ! strings (-1 = less than, 0 = equal, 1 = more than)
    %external %integer %function impstrcmp ( %byte %name l,r )
        %integer lcount, rcount, index
        %byte lx,rx

        lcount = l; ! pick up the counts
        rcount = r;

        index = 1
        %while (lcount > 0) %and (rcount > 0) %cycle
            lx = byteinteger( addr( l ) + index ); ! get the address
            rx = byteinteger( addr( r ) + index ); ! get the address

            %result =  1 %if (lx > rx)
            %result = -1 %if (rx > lx)

            index = index + 1
            lcount = lcount - 1
            rcount = rcount - 1
        %repeat

        ! here we ran out of characters on one or both sides
        %result =  1 %if (lcount > 0)
        %result = -1 %if (rcount > 0)

        ! if here, the strings are identical
        %result = 0
    %end { of "impstrcmp" }

    {--------------------------------------------------------------------------}
    %external %routine impstrcpy ( %byte %name dst, src, %integer len)
        %integer i
        %integer count
        %byte dlen,slen
        %byte %name srcx,dstx

        %if (len = 0) %then len = MAXSTRINGLEN; ! string(*)name - comes from general %name's etc

        dlen = 0;      ! destination length = 0
        slen = src;    ! fetch the source length

        %signal 6,1,2 %if (slen > len)

        count = slen
        dlen = dlen + count;

        ! update the destination count
        dstx == byteinteger( addr( dst) ); ! get the address
        dstx = dlen;                       ! set the new length

        ! copy across the source chars (and the lengths)
        %for i = 1,1,count %cycle
            srcx == byteinteger( addr(src) + i )
            dstx == byteinteger( addr(dst) + i )
            dstx = srcx
        %repeat
    %end { of "impstrcpy" }

    {--------------------------------------------------------------------------}
    %external %routine impstrjam ( %byte %name dst,src, %integer len)
        %integer i
        %integer count
        %byte slen,dlen
        %byte %name srcx,dstx

        %if (len = 0) %then len = MAXSTRINGLEN; ! string(*)name - comes from general %name's etc

        dlen = dst;   ! pick up existing destination length
        slen = src;   ! fetch the source length

        %if (slen > len) %start { force the length to fit }
            count = len
        %else
            count = slen
        %finish
        dlen = count

        ! update the destination count
        dstx == byteinteger( addr( dst) ); ! get the address
        dstx = dlen;                       ! set the new length

        ! copy across the source chars (and length) 
        %for i = 1,1,count %cycle
            srcx == byteinteger( addr(src) + i )
            dstx == byteinteger( addr(dst) + i )
            dstx = srcx
        %repeat
    %end { of "impstrjam" }

    {--------------------------------------------------------------------------}
    %external %routine impstrjcat ( %byte %name dst,src, %integer len )
        %integer i
        %integer count
        %byte dlen,slen
        %byte %name srcx,dstx

        %if (len = 0) %then len = MAXSTRINGLEN; ! string(*)name - comes from general %name's etc

        dlen = dst;   ! pick up existing destination length
        slen = src;   ! fetch the source length

        %if ((dlen + slen) > len) %start { force the length to fit }
            count = len - dlen
        %else
            count = slen
        %finish
        dlen = dlen + count

        ! update the destination count
        dstx == byteinteger( addr( dst) ); ! get the address
        dstx = dlen;                       ! set the new length

        ! copy across the source chars
        %for i = 1,1,count %cycle
            srcx == byteinteger( addr(src) + i )
            dstx == byteinteger( addr(dst) + (dlen - count) + i )
            dstx = srcx
        %repeat
    %end { of "impstrjcat" }

    {--------------------------------------------------------------------------}
    ! IMP resolution - S->A.(B).C; returns 1 for success, 0 for failure
    %external %predicate impstrres ( %byte %name c,b,a,s )
        %integer index, count, i
        %byte slen, alen, blen, clen
        %byte %name sx,ax,bx,cx

        ! Although S,A,B,C are declared equivalent to C format string arrays
        ! This lets us access a char at index i by x[i]
        ! However the string arrays are formatted as IMP strings
        ! Hence, x[0] contains the length of the string.
        ! And x[x[0]] is therefore the last char in the IMP string.
        ! NB. IMP equates a char to a single byte
        ! So an IMP string is a byte addressable array of unsigned bytes.
        ! So x[0] can only hold a value 0..255
        ! NB. Hence IMP strings have at most 255 chars
        !     With an extra prefix byte to indicate the actual string length
        !     Thus an IMP string variable requires at most 256 bytes
        !
        ! NB. A programmer can assign a lesser size than 256 to a string
        !     and needs to be aware of potential "buffer" overflow

        ! For all cases S,B unchanged
        ! case 1:   S -> A.(B).C
        !  sub-case 1A: length(B) > length(S) => %false, A,C unchanged
        !  sub-case 1B: B not in S            => %false, A,C unchanged
        !  sub-case 1C: B in S                => %true,  A := S\(B.C)
        !                                                C := S\(A.B)
    
        ! case 2:   S -> A.(B) - all sub-cases C unchanged
        !  sub-case 2A: length(B) > length(S) => %false, A unchanged
        !  sub-case 2B: B not in S            => %false, A unchanged
        !  sub-case 2C: B in S                => %true,  A := S\B

        ! case 3:   S ->   (B).C - all sub-cases A unchanged
        !  sub-case 3A: length(B) > length(S) => %false, C unchanged
        !  sub-case 3B: B not in S            => %false, C unchanged
        !  sub-case 3C: B in S                => %true,  C := S\B

        ! We know the sizes of S,B since we can use length(S), length(B)
        ! Assume A,C have storage lengths able to hold at most a copy of S

        ! Point to the start address of S,B respectively
        sx == byteinteger( addr( s ) )
        bx == byteinteger( addr( b ) )
        { Now retrieve the lengths of the input strings S,B }
        slen = s
        blen = b

        { Compare the lengths of the B,S strings }
        { B must not be longer than S }
        %if (blen > slen) %start
            { Drat! B is longer so this resolution can't possibly work }
            %false
        %finish

        ! Now to successively try to find B inside S
        { Loop over S and then B to see if B is indeed a sub-string of S }
        { We need to find the location of B in S }
        { So start at the character in S }
        index = 1
        %while ( (index + blen) <= slen + 1) %cycle
            { see if there is a match starting from S[index] }
            { count gives the number of matched characters in B found in S }
            { It indicates we are about to search thupto B[count] }
            count = 0
            %while (count <= blen) %cycle
                { Get next char to compare in B }
                { Remember to skip over the byte/char holding B's length }
                { bx == B[count + 1] }
                bx == byteinteger( addr(b) + 1 + count )

                { Now get the offseted char from S }
                { sx == S[index + count] }
                sx == byteinteger( addr(s) + index + count )

                { Compare the chars }
                { no match implies B cannot start at S[index] }
                %exit %if (sx # bx)

                { Great, byte chars match }
                { So up out count to look at the next char }
                count = count + 1;
            %repeat

            { check if we found string B present in S }
            %if (count = blen) %start

                { Yes, B is inside S and B starts at S[INDEX] }

                { So, we have the invariant over the various string lengths }
                { length(S) = length(A) + length(B) + length(C) }

                { Knowing the start and end location of the strings inside S }
                { String    Start           End               }
                {      S    1               slen              }
                {      A    1               index - 1         }
                {      B    index           index + blen - 1  }
                {      C    index + blen    slen              }

                { Using length = 1 + end - start    }
                { String    Length                  }
                {      S    slen                    }
                {      A    index - 1               }
                {      B    blen                    }
                {      C    slen + 1 - index - blen }

                { Checking the invariant gives }
                {   length(A) + length(B) + length(C) }
                { = index - 1 + blen      + slen + 1 - index - blen }
                { = slen  (after simplifying terms) }

                { Now to determine the lengths of A, C }
                { Determine alen from its end position }
                alen = index - 1

                { Using the invariant }
                clen = slen - (alen + blen)

                { Now populate the A, C strings (if required as output) }
                { Firstly populate the prefix string A in S-> A.(B).C }
                %if (addr(a) # 0) %start
                    { String A has been requested }

                    { copy S into A }
                    { starting at S[1] for alen characters }
                    ax == byteinteger( addr(a) )
                    ax = alen
                    %for i = 1,1,alen %cycle
                        sx == byteinteger( addr(s) + i )
                        ax == byteinteger( addr(a) + i )
                        ax = sx;
                    %repeat
                %finish

                { Now to remember the postfix string C in S-> A.(B).C }
                %if (addr(c) # 0) %start
                    { String C has been requested }

                    ! Ok, we have somewhere to store C
                    cx == byteinteger( addr(c) )
                    cx = clen
                    %for i = 1,1,clen %cycle
                        sx == byteinteger( addr(s) + i + alen + blen )
                        cx == byteinteger( addr(c) + i )
                        cx = sx
                    %repeat
                %finish

                %true
            %finish

            ! here = no match found (as yet!)
            index = index + 1
        %repeat

        ! We have seached all of S and not found B as a sub-string
        ! So report failure, leaving A,C untouched
        %false
    %end { of "impstrres" }

%endoffile
